{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#pyfreeform","title":"PyFreeform","text":"<p>Turn images into art with Python.</p> <p></p>"},{"location":"#three-lines-of-code-infinite-possibilities","title":"Three Lines of Code, Infinite Possibilities","text":"Geometric patterns Flowing curves Parametric shapes <pre><code>from pyfreeform import Scene\n\nscene = Scene.from_image(\"photo.jpg\", grid_size=40)\nfor cell in scene.grid:\n    cell.add_dot(radius=cell.brightness * 4, color=cell.color)\nscene.save(\"artwork.svg\")\n</code></pre>"},{"location":"#choose-your-path","title":"Choose Your Path","text":"<ul> <li> <p>:material-rocket-launch:{ .lg .middle } Getting Started</p> <p>Install PyFreeform and create your first artwork in minutes.</p> <p>:octicons-arrow-right-24: Get started</p> </li> <li> <p>:material-book-open-variant:{ .lg .middle } Guide</p> <p>Learn every feature through progressive, visual examples.</p> <p>:octicons-arrow-right-24: Start learning</p> </li> <li> <p>:material-chef-hat:{ .lg .middle } Recipes</p> <p>Build complete projects: portraits, patterns, typography, and more.</p> <p>:octicons-arrow-right-24: Browse recipes</p> </li> <li> <p>:material-api:{ .lg .middle } API Surface</p> <p>Comprehensive reference for every class, method, and parameter.</p> <p>:octicons-arrow-right-24: Explore the API</p> </li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install pyfreeform\n</code></pre> <p>Requires Python 3.10+ and Pillow (installed automatically).</p>"},{"location":"API_SURFACE/","title":"PyFreeform API Surface Reference","text":""},{"location":"API_SURFACE/#pyfreeform-api-surface-reference","title":"PyFreeform API Surface Reference","text":"<p>A comprehensive guide to every class, method, and concept in PyFreeform v0.3.0, organized to follow the natural discovery flow a developer experiences as they go from \"I just installed this\" to \"I'm building complex generative art.\"</p>"},{"location":"API_SURFACE/#1-the-entry-point-scene","title":"1. The Entry Point: Scene","text":"<p>Everything starts with a <code>Scene</code>. It's the canvas \u2014 it holds your artwork and renders it to SVG.</p>"},{"location":"API_SURFACE/#three-ways-to-create-a-scene","title":"Three Ways to Create a Scene","text":"Constructor Use Case Returns <code>Scene(width, height, background=None)</code> Manual canvas, no grid Scene <code>Scene.from_image(source, *, grid_size=40, cell_size=10, ...)</code> Image-based art Scene with grid <code>Scene.with_grid(*, cols=30, rows=None, cell_size=10, ...)</code> Grid-based art, no image Scene with grid <p><code>Scene.from_image()</code> is the flagship \u2014 load a photo, get a grid where every cell knows the color and brightness of the pixel it overlays.</p> <p><code>Scene.with_grid()</code> gives you the same grid structure but with no image data (cells default to brightness 0.5, color \"#808080\").</p> <p><code>Scene(w, h)</code> is for freeform art \u2014 you place entities at absolute positions, no grid involved.</p>"},{"location":"API_SURFACE/#scene-properties","title":"Scene Properties","text":"Property Type Description <code>scene.width</code> <code>int</code> Canvas width in pixels <code>scene.height</code> <code>int</code> Canvas height in pixels <code>scene.background</code> <code>str \\| None</code> Background color (default: <code>\"#1a1a2e\"</code> midnight blue) <code>scene.grid</code> <code>Grid</code> The primary grid (raises <code>ValueError</code> if none) <code>scene.grids</code> <code>list[Grid]</code> All grids in the scene <code>scene.entities</code> <code>list[Entity]</code> All entities (including those inside grid cells) <code>scene.connections</code> <code>list[Connection]</code> All connections"},{"location":"API_SURFACE/#scene-methods","title":"Scene Methods","text":"Method Description <code>scene.add(*objects)</code> Add entities, connections, or grids. Returns last added. <code>scene.remove(obj)</code> Remove an object. Returns <code>True</code> if found. <code>scene.clear()</code> Remove everything. <code>scene.to_svg()</code> Render to SVG string. <code>scene.save(path)</code> Save to <code>.svg</code> file (adds extension if missing)."},{"location":"API_SURFACE/#from_image-full-signature","title":"<code>from_image()</code> Full Signature","text":"<pre><code>Scene.from_image(\n    source: str | Path | Image,   # File path or Image object\n    *,\n    grid_size: int | None = 40,   # Columns (rows auto from aspect ratio)\n    cell_size: int = 10,          # Base cell size in pixels\n    cell_ratio: float = 1.0,      # Width-to-height ratio (2.0 = domino)\n    cell_width: float | None,     # Explicit cell width (overrides cell_size)\n    cell_height: float | None,    # Explicit cell height (overrides cell_size)\n    background: str | None,       # Background color (default \"#1a1a2e\")\n) -&gt; Scene\n</code></pre> <p>Two modes: - <code>grid_size=N</code> (default): N columns, rows calculated from image aspect ratio. Scene dimensions = grid * cell_size. - <code>grid_size=None</code>: Grid fits the image dimensions. Columns/rows derived from <code>image.width / cell_size</code>.</p>"},{"location":"API_SURFACE/#with_grid-full-signature","title":"<code>with_grid()</code> Full Signature","text":"<pre><code>Scene.with_grid(\n    *,\n    cols: int = 30,               # Columns\n    rows: int | None = None,      # Rows (defaults to cols for square)\n    cell_size: int = 10,          # Base cell size in pixels\n    cell_width: float | None,     # Explicit cell width\n    cell_height: float | None,    # Explicit cell height\n    background: str | None,       # Background color (default \"#1a1a2e\")\n) -&gt; Scene\n</code></pre>"},{"location":"API_SURFACE/#2-the-grid-structure-and-selection","title":"2. The Grid: Structure and Selection","text":"<p>A <code>Grid</code> divides the scene into rows and columns of <code>Cell</code> objects. It provides powerful selection methods for targeting specific cells.</p>"},{"location":"API_SURFACE/#grid-construction","title":"Grid Construction","text":"Constructor Description <code>Grid(cols, rows, cell_size=None, cell_width=None, cell_height=None)</code> Manual grid <code>Grid.from_image(image, cols=None, rows=None, cell_size=10, ...)</code> Grid sized to image"},{"location":"API_SURFACE/#grid-properties","title":"Grid Properties","text":"Property Type Description <code>grid.cols</code> <code>int</code> Number of columns <code>grid.rows</code> <code>int</code> Number of rows <code>grid.cell_width</code> <code>float</code> Cell width in pixels <code>grid.cell_height</code> <code>float</code> Cell height in pixels <code>grid.cell_size</code> <code>(float, float)</code> <code>(cell_width, cell_height)</code> tuple <code>grid.pixel_width</code> <code>float</code> Total width = cols * cell_width <code>grid.pixel_height</code> <code>float</code> Total height = rows * cell_height <code>grid.origin</code> <code>Point</code> Top-left corner position <code>grid.source_image</code> <code>Image \\| None</code> Original source image (if from_image)"},{"location":"API_SURFACE/#cell-access","title":"Cell Access","text":"Operation Description <code>grid[row, col]</code> Access by (row, col) index <code>for cell in grid:</code> Iterate row-by-row, left-to-right <code>len(grid)</code> Total number of cells <code>grid.cell_at(x, y)</code> Get cell at pixel position (or None)"},{"location":"API_SURFACE/#row-column-access","title":"Row &amp; Column Access","text":"Method Returns Description <code>grid.row(i)</code> <code>list[Cell]</code> All cells in row i <code>grid.column(i)</code> <code>list[Cell]</code> All cells in column i <code>grid.all_rows</code> <code>Iterator[list[Cell]]</code> Iterate over all rows <code>grid.all_columns</code> <code>Iterator[list[Cell]]</code> Iterate over all columns"},{"location":"API_SURFACE/#region-selection","title":"Region Selection","text":"Method Returns Description <code>grid.region(row_start, row_end, col_start, col_end)</code> <code>Iterator[Cell]</code> Rectangular region <code>grid.border(thickness=1)</code> <code>Iterator[Cell]</code> Cells on the grid border"},{"location":"API_SURFACE/#cell-merging-cellgroup","title":"Cell Merging (CellGroup)","text":"Method Returns Description <code>grid.merge(row_start, row_end, col_start, col_end)</code> <code>CellGroup</code> Merge region into single surface <code>grid.merge_row(i)</code> <code>CellGroup</code> Merge full row <code>grid.merge_col(i)</code> <code>CellGroup</code> Merge full column <p>A <code>CellGroup</code> is a virtual surface \u2014 it has all the same <code>add_*</code> builder methods as a Cell, and averaged data properties from its constituent cells.</p>"},{"location":"API_SURFACE/#pattern-selection","title":"Pattern Selection","text":"Method Description <code>grid.every(n, offset=0)</code> Every Nth cell (linear count) <code>grid.checkerboard(\"black\" \\| \"white\")</code> Checkerboard pattern <code>grid.where(predicate)</code> Filter by lambda: <code>grid.where(lambda c: c.brightness &gt; 0.5)</code> <code>grid.diagonal(direction=\"down\", offset=0)</code> Main or offset diagonals"},{"location":"API_SURFACE/#data-loading","title":"Data Loading","text":"<pre><code>grid.load_layer(name, source, mode=\"value\")\n</code></pre> <p>Modes: <code>\"value\"</code> (raw), <code>\"normalized\"</code> (0-1), <code>\"hex\"</code> (color string). Normally handled automatically by <code>Scene.from_image()</code>.</p>"},{"location":"API_SURFACE/#3-the-cell-your-creative-unit","title":"3. The Cell: Your Creative Unit","text":"<p><code>Cell</code> extends <code>Surface</code> \u2014 it inherits all 12+ builder methods plus has image data, position helpers, and neighbor access.</p>"},{"location":"API_SURFACE/#typed-data-properties-from-loaded-image","title":"Typed Data Properties (from loaded image)","text":"Property Type Default Description <code>cell.brightness</code> <code>float</code> <code>0.5</code> 0.0 (black) to 1.0 (white) <code>cell.color</code> <code>str</code> <code>\"#808080\"</code> Hex color string <code>cell.rgb</code> <code>(int, int, int)</code> <code>(128, 128, 128)</code> RGB tuple (0-255 each) <code>cell.alpha</code> <code>float</code> <code>1.0</code> 0.0 (transparent) to 1.0 (opaque) <code>cell.data</code> <code>dict</code> <code>{}</code> Raw data dict for custom layers"},{"location":"API_SURFACE/#position-properties-inherited-from-surface","title":"Position Properties (inherited from Surface)","text":"Property Type Description <code>cell.x</code>, <code>cell.y</code> <code>float</code> Top-left corner <code>cell.width</code>, <code>cell.height</code> <code>float</code> Cell dimensions <code>cell.bounds</code> <code>(x, y, w, h)</code> Bounding tuple <code>cell.center</code> <code>Point</code> Center position <code>cell.top_left</code> <code>Point</code> Top-left corner <code>cell.top_right</code> <code>Point</code> Top-right corner <code>cell.bottom_left</code> <code>Point</code> Bottom-left corner <code>cell.bottom_right</code> <code>Point</code> Bottom-right corner"},{"location":"API_SURFACE/#grid-position","title":"Grid Position","text":"Property Type Description <code>cell.row</code> <code>int</code> Row index (0-based) <code>cell.col</code> <code>int</code> Column index (0-based) <code>cell.grid</code> <code>Grid</code> Parent grid <code>cell.normalized_position</code> <code>(float, float)</code> (nx, ny) normalized to 0.0-1.0 within grid"},{"location":"API_SURFACE/#neighbors","title":"Neighbors","text":"Property Returns Direction <code>cell.above</code> <code>Cell \\| None</code> North <code>cell.below</code> <code>Cell \\| None</code> South <code>cell.left</code> <code>Cell \\| None</code> West <code>cell.right</code> <code>Cell \\| None</code> East <code>cell.above_left</code> <code>Cell \\| None</code> Northwest <code>cell.above_right</code> <code>Cell \\| None</code> Northeast <code>cell.below_left</code> <code>Cell \\| None</code> Southwest <code>cell.below_right</code> <code>Cell \\| None</code> Southeast <code>cell.neighbors</code> <code>dict[str, Cell \\| None]</code> 4 cardinal directions <code>cell.neighbors_all</code> <code>dict[str, Cell \\| None]</code> All 8 directions"},{"location":"API_SURFACE/#sub-cell-image-sampling","title":"Sub-Cell Image Sampling","text":"<p>For finer-grained access to the original source image within a cell's area:</p> Method Returns Description <code>cell.sample_image(rx, ry)</code> <code>(int, int, int)</code> RGB at relative position within cell <code>cell.sample_brightness(rx, ry)</code> <code>float</code> Brightness at relative position <code>cell.sample_hex(rx, ry)</code> <code>str</code> Hex color at relative position <p>Where <code>rx</code> and <code>ry</code> are 0.0-1.0 within the cell (0.5, 0.5 = center).</p>"},{"location":"API_SURFACE/#utility","title":"Utility","text":"Method Returns Description <code>cell.distance_to(other)</code> <code>float</code> Pixel distance to Cell, Point, or tuple"},{"location":"API_SURFACE/#4-the-surface-protocol-builder-methods","title":"4. The Surface Protocol: Builder Methods","text":"<p><code>Surface</code> is the base class for <code>Cell</code>, <code>Scene</code>, and <code>CellGroup</code>. It provides 12 builder methods that all work identically across these three surfaces.</p>"},{"location":"API_SURFACE/#named-positions","title":"Named Positions","text":"<p>All <code>at</code> parameters accept named positions or <code>(rx, ry)</code> relative coordinates:</p> Name Relative Description <code>\"center\"</code> <code>(0.5, 0.5)</code> Center of surface <code>\"top_left\"</code> <code>(0.0, 0.0)</code> Top-left corner <code>\"top_right\"</code> <code>(1.0, 0.0)</code> Top-right corner <code>\"bottom_left\"</code> <code>(0.0, 1.0)</code> Bottom-left corner <code>\"bottom_right\"</code> <code>(1.0, 1.0)</code> Bottom-right corner <code>\"top\"</code> <code>(0.5, 0.0)</code> Top center <code>\"bottom\"</code> <code>(0.5, 1.0)</code> Bottom center <code>\"left\"</code> <code>(0.0, 0.5)</code> Left center <code>\"right\"</code> <code>(1.0, 0.5)</code> Right center"},{"location":"API_SURFACE/#parametric-positioning-along-t-align","title":"Parametric Positioning: <code>along</code> / <code>t</code> / <code>align</code>","text":"<p>All builder methods (except <code>add_fill</code>, <code>add_border</code>) support parametric positioning:</p> <ul> <li><code>along</code>: Any <code>Pathable</code> object (Line, Curve, Ellipse, Path, Connection, or custom)</li> <li><code>t</code>: Parameter 0.0 (start) to 1.0 (end) along the path</li> <li><code>align</code>: If <code>True</code>, rotate the entity to follow the path's tangent direction</li> </ul> <p>This is the \"killer feature\" \u2014 position any element along any path: </p><pre><code>line = cell.add_diagonal()\ncell.add_dot(along=line, t=cell.brightness)  # Dot slides along diagonal\n</code></pre><p></p>"},{"location":"API_SURFACE/#complete-builder-reference","title":"Complete Builder Reference","text":""},{"location":"API_SURFACE/#add_dot-at-along-t-radius5-colorblack-z_index0-opacity10-styledotstyle","title":"<code>add_dot(*, at, along, t, radius=5, color=\"black\", z_index=0, opacity=1.0, style=DotStyle)</code>","text":"<p>Creates a filled circle. Default position: center.</p>"},{"location":"API_SURFACE/#add_line-start-end-along-t-align-width1-colorblack-z_index0-capround-start_cap-end_cap-opacity10-stylelinestyle","title":"<code>add_line(*, start, end, along, t, align, width=1, color=\"black\", z_index=0, cap=\"round\", start_cap, end_cap, opacity=1.0, style=LineStyle)</code>","text":"<p>Creates a line segment. Default: center to center (zero-length).</p>"},{"location":"API_SURFACE/#add_diagonal-startbottom_left-endtop_right-along-t-align-width1-colorblack-z_index0-capround-start_cap-end_cap-opacity10-stylelinestyle","title":"<code>add_diagonal(*, start=\"bottom_left\", end=\"top_right\", along, t, align, width=1, color=\"black\", z_index=0, cap=\"round\", start_cap, end_cap, opacity=1.0, style=LineStyle)</code>","text":"<p>Convenience for corner-to-corner lines. Delegates to <code>add_line()</code>.</p>"},{"location":"API_SURFACE/#add_curve-startbottom_left-endtop_right-curvature05-along-t-align-width1-colorblack-z_index0-capround-start_cap-end_cap-opacity10-stylelinestyle","title":"<code>add_curve(*, start=\"bottom_left\", end=\"top_right\", curvature=0.5, along, t, align, width=1, color=\"black\", z_index=0, cap=\"round\", start_cap, end_cap, opacity=1.0, style=LineStyle)</code>","text":"<p>Creates a quadratic Bezier curve. <code>curvature</code>: 0 = straight, positive = bows left, negative = bows right.</p>"},{"location":"API_SURFACE/#add_pathpathable-segments64-closedfalse-start_t00-end_t10-width1-colorblack-fillnone-z_index0-capround-start_cap-end_cap-opacity10-fill_opacity-stroke_opacity-stylelinestyle","title":"<code>add_path(pathable, *, segments=64, closed=False, start_t=0.0, end_t=1.0, width=1, color=\"black\", fill=None, z_index=0, cap=\"round\", start_cap, end_cap, opacity=1.0, fill_opacity, stroke_opacity, style=LineStyle)</code>","text":"<p>Renders any Pathable as a smooth SVG <code>&lt;path&gt;</code> using cubic Bezier approximation. Supports arcs via <code>start_t</code>/<code>end_t</code>, closed paths with fill, and dual opacity.</p>"},{"location":"API_SURFACE/#add_ellipse-at-along-t-align-rx-ry-rotation0-fillblack-strokenone-stroke_width1-z_index0-opacity10-fill_opacity-stroke_opacity-styleshapestyle","title":"<code>add_ellipse(*, at, along, t, align, rx, ry, rotation=0, fill=\"black\", stroke=None, stroke_width=1, z_index=0, opacity=1.0, fill_opacity, stroke_opacity, style=ShapeStyle)</code>","text":"<p>Creates an ellipse. Default radii: 40% of surface dimensions. The ellipse itself is a Pathable \u2014 you can position other elements along it.</p>"},{"location":"API_SURFACE/#add_polygonvertices-along-t-align-fillblack-strokenone-stroke_width1-z_index0-opacity10-fill_opacity-stroke_opacity-rotation0-styleshapestyle","title":"<code>add_polygon(vertices, *, along, t, align, fill=\"black\", stroke=None, stroke_width=1, z_index=0, opacity=1.0, fill_opacity, stroke_opacity, rotation=0, style=ShapeStyle)</code>","text":"<p>Creates a polygon from relative-coordinate vertices (0-1). Use <code>Polygon.hexagon()</code>, <code>Polygon.star()</code>, etc. for common shapes.</p>"},{"location":"API_SURFACE/#add_rect-at-along-t-align-width-height-rotation0-fillblack-strokenone-stroke_width1-opacity10-fill_opacity-stroke_opacity-z_index0-styleshapestyle","title":"<code>add_rect(*, at, along, t, align, width, height, rotation=0, fill=\"black\", stroke=None, stroke_width=1, opacity=1.0, fill_opacity, stroke_opacity, z_index=0, style=ShapeStyle)</code>","text":"<p>Creates a rectangle. <code>at</code> specifies the center position. Default size: 60% of surface.</p>"},{"location":"API_SURFACE/#add_textcontent-at-along-t-align-font_size-colorblack-font_familysans-serif-boldfalse-italicfalse-text_anchor-baselinemiddle-rotation0-z_index0-opacity10-start_offset00-end_offset10-styletextstyle","title":"<code>add_text(content, *, at, along, t, align, font_size, color=\"black\", font_family=\"sans-serif\", bold=False, italic=False, text_anchor, baseline=\"middle\", rotation=0, z_index=0, opacity=1.0, start_offset=0.0, end_offset=1.0, style=TextStyle)</code>","text":"<p>Creates text. Two modes with <code>along</code>: - <code>along</code> + <code>t</code>: Position text at a point on the path, optionally align to tangent. - <code>along</code> without <code>t</code>: Warp text along the path using SVG <code>&lt;textPath&gt;</code> (auto-sizes font to fill path).</p>"},{"location":"API_SURFACE/#add_fill-colorblack-opacity10-z_index0-stylefillstyle","title":"<code>add_fill(*, color=\"black\", opacity=1.0, z_index=0, style=FillStyle)</code>","text":"<p>Fill the entire surface with a solid color.</p>"},{"location":"API_SURFACE/#add_border-colorcccccc-width05-z_index0-opacity10-styleborderstyle","title":"<code>add_border(*, color=\"#cccccc\", width=0.5, z_index=0, opacity=1.0, style=BorderStyle)</code>","text":"<p>Add a stroke-only border around the surface.</p>"},{"location":"API_SURFACE/#placeentity-atcenter-add_entityentity-atcenter","title":"<code>place(entity, at=\"center\")</code> / <code>add_entity(entity, at=\"center\")</code>","text":"<p>Place an existing entity into this surface. Works for any entity type including <code>EntityGroup</code>.</p>"},{"location":"API_SURFACE/#5-entities-the-drawing-primitives","title":"5. Entities: The Drawing Primitives","text":"<p>All entities inherit from <code>Entity</code> and share these common capabilities.</p>"},{"location":"API_SURFACE/#entity-base-class","title":"Entity Base Class","text":"Property/Method Description <code>entity.position</code> Current position (<code>Point</code>) <code>entity.x</code>, <code>entity.y</code> Position coordinates <code>entity.z_index</code> Layer ordering (higher = on top) <code>entity.cell</code> Containing Surface (if placed) <code>entity.connections</code> Set of connections involving this entity <code>entity.data</code> Custom data dictionary"},{"location":"API_SURFACE/#movement","title":"Movement","text":"Method Description <code>entity.move_to(x, y)</code> Move to absolute position <code>entity.move_by(dx, dy)</code> Move by relative offset <code>entity.translate(dx, dy)</code> Alias for <code>move_by()</code> <code>entity.move_to_cell(cell, at=\"center\")</code> Move to position within a cell"},{"location":"API_SURFACE/#transforms","title":"Transforms","text":"Method Description <code>entity.rotate(angle, origin=None)</code> Rotate in degrees (counterclockwise) <code>entity.scale(factor, origin=None)</code> Scale (2.0 = double size) <code>entity.fit_to_cell(scale=1.0, recenter=True, *, at=None)</code> Auto-scale to fit within containing cell <code>entity.fit_within(target, scale=1.0, recenter=True, *, at=None)</code> Auto-scale to fit within another entity's inner bounds"},{"location":"API_SURFACE/#relationships","title":"Relationships","text":"Method Description <code>entity.connect(other, style, start_anchor, end_anchor)</code> Create a Connection to another entity <code>entity.anchor(name)</code> Get named anchor point <code>entity.anchor_names</code> List of available anchor names <code>entity.offset_from(anchor_name, dx, dy)</code> Point offset from an anchor <code>entity.place_beside(other, side=\"right\", gap=0)</code> Position beside another entity using bounding boxes"},{"location":"API_SURFACE/#abstract-methods-implemented-by-each-entity-type","title":"Abstract Methods (implemented by each entity type)","text":"Method Description <code>entity.to_svg()</code> Render to SVG element string <code>entity.bounds()</code> Bounding box: <code>(min_x, min_y, max_x, max_y)</code> <code>entity.inner_bounds()</code> Inscribed rectangle (default: same as bounds)"},{"location":"API_SURFACE/#5a-dot","title":"5a. Dot","text":"<p>A filled circle. The simplest entity.</p> <pre><code>Dot(x=0, y=0, radius=5, color=\"black\", z_index=0, opacity=1.0)\n</code></pre> <ul> <li>Anchors: <code>\"center\"</code></li> <li><code>color=</code> parameter (not <code>fill=</code>)</li> <li><code>inner_bounds()</code> returns inscribed square</li> </ul>"},{"location":"API_SURFACE/#5b-line","title":"5b. Line","text":"<p>A line segment between two points. Implements the Pathable protocol.</p> <pre><code>Line(x1, y1, x2, y2, width=1, color=\"black\", z_index=0, cap=\"round\",\n     start_cap=None, end_cap=None, opacity=1.0)\nLine.from_points(start, end, ...)\n</code></pre> <ul> <li>Anchors: <code>\"start\"</code>, <code>\"center\"</code>, <code>\"end\"</code></li> <li>Pathable: <code>line.point_at(t)</code> returns a point along the line</li> <li>Properties: <code>line.start</code>, <code>line.end</code>, <code>line.length</code></li> <li>Methods: <code>line.set_endpoints(start, end)</code>, <code>line.arc_length()</code>, <code>line.angle_at(t)</code>, <code>line.to_svg_path_d()</code></li> <li>Cap values: <code>\"round\"</code>, <code>\"square\"</code>, <code>\"butt\"</code>, <code>\"arrow\"</code>, <code>\"arrow_in\"</code></li> </ul>"},{"location":"API_SURFACE/#5c-curve","title":"5c. Curve","text":"<p>A quadratic Bezier curve. Implements the Pathable protocol.</p> <pre><code>Curve(x1, y1, x2, y2, curvature=0.5, width=1, color=\"black\", z_index=0,\n      cap=\"round\", start_cap=None, end_cap=None, opacity=1.0)\nCurve.from_points(start, end, curvature=0.5, ...)\n</code></pre> <ul> <li>Anchors: <code>\"start\"</code>, <code>\"center\"</code>, <code>\"end\"</code>, <code>\"control\"</code></li> <li>Pathable: <code>curve.point_at(t)</code> returns a point along the Bezier curve</li> <li>Curvature: 0 = straight, positive = bows left, negative = bows right, typical range -1 to 1</li> <li>Properties: <code>curve.start</code>, <code>curve.end</code>, <code>curve.curvature</code>, <code>curve.control</code></li> <li>Methods: <code>curve.arc_length()</code>, <code>curve.angle_at(t)</code>, <code>curve.to_svg_path_d()</code></li> </ul>"},{"location":"API_SURFACE/#5d-ellipse","title":"5d. Ellipse","text":"<p>An ellipse (oval). Implements the Pathable protocol.</p> <pre><code>Ellipse(x, y, rx=10, ry=10, rotation=0, fill=\"black\", stroke=None,\n        stroke_width=1, z_index=0, opacity=1.0, fill_opacity=None, stroke_opacity=None)\nEllipse.at_center(center, rx, ry, ...)\n</code></pre> <ul> <li>Anchors: <code>\"center\"</code>, <code>\"right\"</code>, <code>\"top\"</code>, <code>\"left\"</code>, <code>\"bottom\"</code></li> <li>Pathable: <code>ellipse.point_at(t)</code> \u2014 t=0 rightmost, t=0.25 top, t=0.5 left, t=0.75 bottom</li> <li><code>fill=</code> parameter (not <code>color=</code>)</li> <li>Dual opacity: <code>fill_opacity</code> and <code>stroke_opacity</code> override <code>opacity</code></li> <li>Methods: <code>point_at_angle(degrees)</code>, <code>arc_length()</code>, <code>angle_at(t)</code>, <code>to_svg_path_d()</code>, <code>inner_bounds()</code></li> </ul>"},{"location":"API_SURFACE/#5e-polygon","title":"5e. Polygon","text":"<p>A closed polygon from vertices. Includes shape classmethods for common shapes.</p> <pre><code>Polygon(vertices, fill=\"black\", stroke=None, stroke_width=1, z_index=0,\n        opacity=1.0, fill_opacity=None, stroke_opacity=None)\n</code></pre> <ul> <li>Anchors: <code>\"center\"</code> + <code>\"v0\"</code>, <code>\"v1\"</code>, <code>\"v2\"</code>, ...</li> <li><code>fill=</code> parameter (not <code>color=</code>)</li> <li>Dual opacity: <code>fill_opacity</code> and <code>stroke_opacity</code></li> <li>Position is centroid of vertices</li> </ul>"},{"location":"API_SURFACE/#shape-classmethods","title":"Shape Classmethods","text":"<p>All return <code>list[tuple[float, float]]</code> in relative coordinates (0-1), ready for <code>add_polygon()</code>:</p> Method Description <code>Polygon.triangle(size=1.0, center=(0.5, 0.5))</code> Equilateral triangle (pointing up) <code>Polygon.square(size=0.8, center=(0.5, 0.5))</code> Axis-aligned square <code>Polygon.diamond(size=0.8, center=(0.5, 0.5))</code> Rotated square (45 degrees) <code>Polygon.hexagon(size=0.8, center=(0.5, 0.5))</code> Regular hexagon <code>Polygon.star(points=5, size=0.8, inner_ratio=0.4, center=(0.5, 0.5))</code> Star with N points <code>Polygon.regular_polygon(sides, size=0.8, center=(0.5, 0.5))</code> Regular N-gon <code>Polygon.squircle(size=0.8, center=(0.5, 0.5), n=4, points=32)</code> Superellipse (n=2 circle, n=4 squircle) <code>Polygon.rounded_rect(size=0.8, center=(0.5, 0.5), corner_radius=0.2, points_per_corner=8)</code> Rectangle with rounded corners"},{"location":"API_SURFACE/#5f-rect","title":"5f. Rect","text":"<p>A rectangle with optional rotation.</p> <pre><code>Rect(x, y, width, height, fill=\"black\", stroke=None, stroke_width=1,\n     rotation=0, z_index=0, opacity=1.0, fill_opacity=None, stroke_opacity=None)\nRect.at_center(center, width, height, rotation=0, ...)\n</code></pre> <ul> <li>Anchors: <code>\"center\"</code>, <code>\"top_left\"</code>, <code>\"top_right\"</code>, <code>\"bottom_left\"</code>, <code>\"bottom_right\"</code>, <code>\"top\"</code>, <code>\"bottom\"</code>, <code>\"left\"</code>, <code>\"right\"</code></li> <li><code>fill=</code> parameter (not <code>color=</code>)</li> <li>Dual opacity: <code>fill_opacity</code> and <code>stroke_opacity</code></li> <li><code>x, y</code> is top-left corner; <code>Rect.at_center()</code> positions by center</li> <li>Rotation: stored as <code>rotation</code> attribute, emits SVG <code>transform=\"rotate()\"</code></li> <li>Rotation-aware anchors (anchors account for rotation angle)</li> </ul>"},{"location":"API_SURFACE/#5g-text","title":"5g. Text","text":"<p>A text label with rich formatting.</p> <pre><code>Text(x=0, y=0, content=\"\", font_size=16, color=\"black\",\n     font_family=\"sans-serif\", font_style=\"normal\", font_weight=\"normal\",\n     bold=False, italic=False, text_anchor=\"middle\", baseline=\"middle\",\n     rotation=0, z_index=0, opacity=1.0)\n</code></pre> <ul> <li>Anchors: <code>\"center\"</code></li> <li><code>color=</code> parameter</li> <li>Sugar: <code>bold=True</code> sets <code>font_weight=\"bold\"</code>, <code>italic=True</code> sets <code>font_style=\"italic\"</code></li> <li>Text alignment: <code>text_anchor</code> = <code>\"start\"</code> / <code>\"middle\"</code> / <code>\"end\"</code>, <code>baseline</code> = <code>\"auto\"</code> / <code>\"middle\"</code> / <code>\"hanging\"</code> / etc.</li> <li>Rotation: <code>rotation</code> attribute, SVG <code>transform=\"rotate()\"</code></li> <li>Bounds: Uses Pillow for accurate font measurement; heuristic fallback</li> <li>TextPath: <code>text.set_textpath(path_id, path_d, start_offset, text_length)</code> for warping along paths</li> </ul>"},{"location":"API_SURFACE/#5h-path","title":"5h. Path","text":"<p>Renders any Pathable as a smooth SVG path. Implements the Pathable protocol itself.</p> <pre><code>Path(\n    pathable,           # Any object with point_at(t)\n    *,\n    segments=64,        # Number of cubic Bezier segments\n    closed=False,       # Close path smoothly (enables fill)\n    start_t=0.0,        # Start parameter (for arcs/sub-paths)\n    end_t=1.0,          # End parameter (for arcs/sub-paths)\n    width=1,            # Stroke width\n    color=\"black\",      # Stroke color\n    fill=None,          # Fill color (only if closed)\n    z_index=0,\n    cap=\"round\",\n    start_cap=None,\n    end_cap=None,\n    opacity=1.0,\n    fill_opacity=None,\n    stroke_opacity=None,\n)\n</code></pre> <ul> <li>Anchors: <code>\"start\"</code>, <code>\"center\"</code>, <code>\"end\"</code></li> <li>Pathable: <code>path.point_at(t)</code> evaluates the stored Bezier segments</li> <li>Algorithm: Hermite interpolation \u2192 cubic Bezier fitting with C1 continuity</li> <li>Sub-paths: Use <code>start_t</code>/<code>end_t</code> to render a portion of any path (e.g., quarter of an ellipse)</li> <li>Methods: <code>arc_length()</code>, <code>angle_at(t)</code>, <code>to_svg_path_d()</code></li> </ul>"},{"location":"API_SURFACE/#5i-entitygroup","title":"5i. EntityGroup","text":"<p>A reusable composite entity. Children positioned relative to (0,0), rendered as SVG <code>&lt;g&gt;</code>.</p> <pre><code>EntityGroup(x=0, y=0, z_index=0)\n</code></pre> <ul> <li><code>group.add(entity)</code>: Add child (positioned relative to local origin)</li> <li><code>group.children</code>: List of children (copy)</li> <li><code>group._scale</code>: Internal scale factor, modified by <code>scale()</code></li> <li>Placement: <code>cell.place(group)</code> / <code>cell.add_entity(group)</code> \u2014 centers in cell</li> <li>Fitting: <code>group.fit_to_cell(fraction)</code> \u2014 auto-scales to fit cell bounds</li> <li>SVG: <code>&lt;g transform=\"translate(x,y) scale(s)\"&gt;</code> \u2014 children never mutated</li> <li>Reuse: Wrap creation in a factory function; each call returns new instance</li> </ul>"},{"location":"API_SURFACE/#6-the-pathable-protocol","title":"6. The Pathable Protocol","text":"<p>The <code>Pathable</code> protocol defines a single method:</p> <pre><code>class Pathable:\n    def point_at(self, t: float) -&gt; Point\n</code></pre> <p>Where <code>t</code> ranges from 0.0 (start) to 1.0 (end). This enables the <code>along</code>/<code>t</code> parametric positioning system.</p>"},{"location":"API_SURFACE/#built-in-pathables","title":"Built-in Pathables","text":"Entity Description <code>Line</code> Linear interpolation start\u2192end <code>Curve</code> Quadratic Bezier <code>Ellipse</code> Parametric ellipse (t=0 right, t=0.25 top, t=0.5 left, t=0.75 bottom) <code>Path</code> Evaluates stored cubic Bezier segments <code>Connection</code> Dynamic path between entities"},{"location":"API_SURFACE/#optional-pathable-methods","title":"Optional Pathable Methods","text":"<p>These methods enable additional features when present:</p> Method Used By Description <code>arc_length()</code> <code>add_text(along=)</code> Total path length for text sizing <code>angle_at(t)</code> <code>get_angle_at()</code> Tangent angle for alignment <code>to_svg_path_d()</code> <code>add_text(along=)</code> SVG path for <code>&lt;textPath&gt;</code> warping"},{"location":"API_SURFACE/#custom-pathables","title":"Custom Pathables","text":"<p>Any object with <code>point_at(t: float) -&gt; Point</code> works:</p> <pre><code>class Wave:\n    def point_at(self, t):\n        x = self.start.x + t * (self.end.x - self.start.x)\n        y = self.center_y + self.amplitude * math.sin(t * self.frequency * 2 * math.pi)\n        return Point(x, y)\n</code></pre>"},{"location":"API_SURFACE/#7-connections","title":"7. Connections","text":"<p>Links between entities that auto-update when entities move.</p> <pre><code>Connection(start, end, start_anchor=\"center\", end_anchor=\"center\", style=None)\n</code></pre> <p>Or via the entity method: </p><pre><code>connection = entity1.connect(entity2, style=ConnectionStyle(...), start_anchor=\"center\", end_anchor=\"center\")\n</code></pre><p></p> <ul> <li><code>style</code> accepts <code>ConnectionStyle</code> or <code>dict</code> with <code>width</code>, <code>color</code>, <code>z_index</code>, <code>cap</code> keys</li> <li>Connections are rendered as lines between anchor points</li> <li>Added to scene via <code>scene.add(connection)</code> (entity.connect() doesn't auto-add)</li> <li>Support cap system (arrow, arrow_in, custom)</li> </ul>"},{"location":"API_SURFACE/#8-transforms-and-fitting","title":"8. Transforms and Fitting","text":""},{"location":"API_SURFACE/#entity-transforms","title":"Entity Transforms","text":"<p>All entities support: - <code>rotate(angle, origin)</code> \u2014 Degrees counterclockwise. Default origin varies by entity type. - <code>scale(factor, origin)</code> \u2014 2.0 = double size. Scales both geometry and position.</p> <p>Each entity type handles transforms appropriately: - Dot: Scales radius - Line/Curve: Rotates/scales both endpoints - Ellipse: Scales radii, updates intrinsic rotation - Polygon: Transforms all vertices - Text: Scales font_size - Path: Transforms all Bezier control points - EntityGroup: Accumulates internal <code>_scale</code> factor</p>"},{"location":"API_SURFACE/#fit_to_cellscale10-recentertrue-atnone","title":"<code>fit_to_cell(scale=1.0, recenter=True, *, at=None)</code>","text":"<p>Auto-scales and positions any entity to fit within its containing cell.</p> <ul> <li><code>scale</code>: Fraction of cell to fill (0.0-1.0). Default 1.0 fills entire cell.</li> <li><code>recenter</code>: If True, centers in cell after scaling.</li> <li><code>at=(rx, ry)</code>: Position-aware mode. Entity is placed at relative position within cell, with available space constrained by nearest edges.</li> </ul>"},{"location":"API_SURFACE/#fit_withintarget-scale10-recentertrue-atnone","title":"<code>fit_within(target, scale=1.0, recenter=True, *, at=None)</code>","text":"<p>Same concept, but fits within another entity's <code>inner_bounds()</code> instead of the cell.</p>"},{"location":"API_SURFACE/#9-color-and-styling","title":"9. Color and Styling","text":""},{"location":"API_SURFACE/#the-color-parameter-split","title":"The Color Parameter Split","text":"<p>This is a critical API distinction:</p> Parameter Used by Entity property <code>color=</code> Dot, Line, Curve, Text, add_dot, add_line, add_curve, add_text, add_fill, add_border, all style classes <code>.color</code> <code>fill=</code> Rect, Ellipse, Polygon, add_rect, add_ellipse, add_polygon, Path (for closed paths) <code>.fill</code> <p><code>ShapeStyle.color</code> maps to <code>fill=</code> when applied to shapes.</p>"},{"location":"API_SURFACE/#color-formats","title":"Color Formats","text":"<p>The <code>Color</code> utility accepts: - Named colors: <code>\"red\"</code>, <code>\"coral\"</code>, <code>\"navy\"</code>, etc. - Hex: <code>\"#ff0000\"</code>, <code>\"#f00\"</code>, <code>\"#FF0000\"</code> - RGB tuple: <code>(255, 0, 0)</code></p>"},{"location":"API_SURFACE/#opacity-system","title":"Opacity System","text":"<ul> <li><code>opacity</code> on every entity and style: 0.0 (transparent) to 1.0 (opaque). Default 1.0 emits no SVG attribute.</li> <li><code>fill_opacity</code> / <code>stroke_opacity</code> on shapes (Rect, Ellipse, Polygon, Path, ShapeStyle): optional overrides for independent control.</li> <li>Simple entities (Dot, Line, Curve, Text, Connection): SVG <code>opacity</code> attribute.</li> <li>Shapes: SVG <code>fill-opacity</code> + <code>stroke-opacity</code> attributes.</li> </ul>"},{"location":"API_SURFACE/#style-classes","title":"Style Classes","text":"<p>7 immutable dataclasses with <code>.with_*()</code> builder methods:</p> Class For Key Fields <code>DotStyle</code> <code>add_dot()</code> <code>radius</code>, <code>color</code>, <code>z_index</code>, <code>opacity</code> <code>LineStyle</code> <code>add_line()</code>, <code>add_diagonal()</code>, <code>add_curve()</code>, <code>add_path()</code> <code>width</code>, <code>color</code>, <code>z_index</code>, <code>cap</code>, <code>start_cap</code>, <code>end_cap</code>, <code>opacity</code> <code>FillStyle</code> <code>add_fill()</code> <code>color</code>, <code>opacity</code>, <code>z_index</code> <code>BorderStyle</code> <code>add_border()</code> <code>width</code>, <code>color</code>, <code>z_index</code>, <code>opacity</code> <code>ShapeStyle</code> <code>add_ellipse()</code>, <code>add_polygon()</code>, <code>add_rect()</code> <code>color</code>, <code>stroke</code>, <code>stroke_width</code>, <code>z_index</code>, <code>opacity</code>, <code>fill_opacity</code>, <code>stroke_opacity</code> <code>TextStyle</code> <code>add_text()</code> <code>font_size</code>, <code>color</code>, <code>font_family</code>, <code>bold</code>, <code>italic</code>, <code>text_anchor</code>, <code>baseline</code>, <code>rotation</code>, <code>z_index</code>, <code>opacity</code> <code>ConnectionStyle</code> <code>Connection</code>, <code>entity.connect()</code> <code>width</code>, <code>color</code>, <code>z_index</code>, <code>cap</code>, <code>start_cap</code>, <code>end_cap</code>, <code>opacity</code> <p>Example builder pattern: </p><pre><code>base_style = LineStyle(width=2, color=\"coral\")\nthick_style = base_style.with_width(4)\narrow_style = base_style.with_end_cap(\"arrow\")\n</code></pre><p></p>"},{"location":"API_SURFACE/#palettes","title":"Palettes","text":"<p>8 pre-built color palettes with 6 named colors each:</p> Palette Background Vibe <code>Palette.midnight()</code> <code>#1a1a2e</code> Dark blue with coral accent <code>Palette.sunset()</code> <code>#2d1b4e</code> Warm oranges and purples <code>Palette.ocean()</code> <code>#0a1628</code> Cool blues and teals <code>Palette.forest()</code> <code>#1a2e1a</code> Natural greens and earth <code>Palette.monochrome()</code> <code>#0a0a0a</code> Black, white, grays <code>Palette.paper()</code> <code>#fafafa</code> Light, clean, minimalist <code>Palette.neon()</code> <code>#0d0d0d</code> Vibrant neon electric <code>Palette.pastel()</code> <code>#fef6e4</code> Soft, gentle pastels <p>Named colors: <code>background</code>, <code>primary</code>, <code>secondary</code>, <code>accent</code>, <code>line</code>, <code>grid</code>.</p> <p>Methods: <code>with_background(color)</code>, <code>inverted()</code>, <code>all_colors()</code>, iteration.</p>"},{"location":"API_SURFACE/#10-cap-system","title":"10. Cap System","text":"<p>Line/Curve/Connection endpoints support custom caps:</p> Built-in Cap Description <code>\"round\"</code> Standard SVG round cap <code>\"square\"</code> SVG square cap <code>\"butt\"</code> SVG butt cap (flat) <code>\"arrow\"</code> Arrowhead marker at endpoint <code>\"arrow_in\"</code> Inward-pointing arrowhead <p>Per-end caps: <code>start_cap</code> and <code>end_cap</code> override the base <code>cap</code>: </p><pre><code>cell.add_line(start=\"left\", end=\"right\", cap=\"round\", end_cap=\"arrow\")\n</code></pre><p></p> <p>Custom caps via registry: </p><pre><code>from pyfreeform import register_cap\nregister_cap(\"diamond\", my_diamond_generator)\n</code></pre><p></p>"},{"location":"API_SURFACE/#11-the-point-type","title":"11. The Point Type","text":"<pre><code>from pyfreeform import Point\n</code></pre> <p><code>Point</code> is a <code>NamedTuple</code> with <code>x</code> and <code>y</code> fields. Subscriptable: <code>point[0]</code>, <code>point[1]</code>.</p> Method Description <code>Point(x, y)</code> Create a point <code>point.x</code>, <code>point.y</code> Access coordinates <code>point[0]</code>, <code>point[1]</code> Subscript access <code>point.distance_to(other)</code> Euclidean distance <code>point.midpoint(other)</code> Midpoint between two points <code>point.lerp(other, t)</code> Linear interpolation <code>point + Point(dx, dy)</code> Addition <code>point - Point(dx, dy)</code> Subtraction"},{"location":"API_SURFACE/#12-image-processing","title":"12. Image Processing","text":""},{"location":"API_SURFACE/#image-class","title":"Image Class","text":"<pre><code>from pyfreeform import Image\nimage = Image.load(\"photo.jpg\")\n</code></pre> Method/Property Description <code>Image.load(path)</code> Load from file <code>Image.from_pil(pil_image)</code> Create from PIL Image <code>image.width</code>, <code>image.height</code> Dimensions <code>image.has_alpha</code> Whether image has alpha channel <code>image[\"brightness\"]</code> Get brightness Layer <code>image[\"red\"]</code>, <code>[\"green\"]</code>, <code>[\"blue\"]</code>, <code>[\"alpha\"]</code> Channel layers <code>image.rgb_at(x, y)</code> RGB at pixel position <code>image.hex_at(x, y)</code> Hex color at pixel position <code>image.resize(width, height)</code> Resize image <code>image.fit(max_dim)</code> Fit within max dimension <code>image.quantize(levels)</code> Reduce to N levels <code>image.downscale(factor)</code> Downscale by factor"},{"location":"API_SURFACE/#layer-class","title":"Layer Class","text":"<p>A single-channel grayscale array (used for brightness, individual color channels, etc.):</p> Property/Method Description <code>layer.width</code>, <code>layer.height</code> Dimensions <code>layer[x, y]</code> Value at position (0-255)"},{"location":"API_SURFACE/#13-utility-functions","title":"13. Utility Functions","text":""},{"location":"API_SURFACE/#map_rangevalue-in_min0-in_max1-out_min0-out_max1-clampfalse","title":"<code>map_range(value, in_min=0, in_max=1, out_min=0, out_max=1, clamp=False)</code>","text":"<p>Map a value from one range to another. Convenience for creative coding.</p> <pre><code>from pyfreeform import map_range\n\nrotation = map_range(cell.brightness, 0, 1, 0, 360)\nradius = map_range(cell.brightness, 0, 1, 2, 10)\n</code></pre>"},{"location":"API_SURFACE/#get_angle_atpathable-t","title":"<code>get_angle_at(pathable, t)</code>","text":"<p>Compute the tangent angle at parameter <code>t</code> on a Pathable. Used internally by the <code>align</code> system.</p> <pre><code>from pyfreeform import get_angle_at\nangle = get_angle_at(curve, 0.5)  # Angle in degrees at midpoint\n</code></pre>"},{"location":"API_SURFACE/#displayscene_or_svg","title":"<code>display(scene_or_svg)</code>","text":"<p>Display an SVG in the current environment (Jupyter notebook, etc.).</p>"},{"location":"API_SURFACE/#14-relationship-map","title":"14. Relationship Map","text":"<pre><code>Scene \u2500\u2500has\u2500\u2500\u25b6 Grid \u2500\u2500has\u2500\u2500\u25b6 Cell (Surface)\n  \u2502              \u2502              \u2502\n  \u2502 (Surface)    \u2502 selections   \u2502 builder methods\n  \u2502 add_*()      \u2502 .where()     \u2502 add_dot(), add_line(), ...\n  \u2502              \u2502 .border()    \u2502\n  \u2502              \u2502 .merge() \u2500\u2500\u25b6 CellGroup (Surface)\n  \u2502              \u2502\n  \u2502 add()        \u2502 from_image() loads Image\n  \u25bc              \u25bc\nEntity \u25c0\u2500\u2500 Dot, Line, Curve, Ellipse, Polygon, Rect, Text, Path, EntityGroup\n  \u2502\n  \u2502 connect()\n  \u25bc\nConnection\n  \u2502\n  \u2502 Pathable protocol: point_at(t)\n  \u25bc\nLine, Curve, Ellipse, Path, Connection  \u25c0\u2500\u2500 any custom class with point_at(t)\n</code></pre>"},{"location":"API_SURFACE/#key-design-principles","title":"Key Design Principles","text":"<ol> <li>Surface protocol: Cell, Scene, CellGroup all share identical <code>add_*</code> methods</li> <li>Pathable protocol: Position anything along anything with <code>along</code>/<code>t</code></li> <li><code>fill=</code> vs <code>color=</code>: Shapes use <code>fill</code>, everything else uses <code>color</code></li> <li>Immutable styles: Style classes with <code>.with_*()</code> builder methods</li> <li>z_index layering: Higher values render on top, same values preserve add-order</li> <li>Everything returns self: Transform methods chain: <code>entity.rotate(45).scale(0.5).move_by(10, 0)</code></li> </ol>"},{"location":"DESIGN_FLOW/","title":"wiki Design-Flow Document","text":""},{"location":"DESIGN_FLOW/#wiki-design-flow-document","title":"wiki Design-Flow Document","text":"<p>The blueprint for the new PyFreeform documentation. Describes the structure, user experience, visual design, generation system, and every page in the new wiki.</p>"},{"location":"DESIGN_FLOW/#philosophy","title":"Philosophy","text":"<p>One sentence: PyFreeform turns images and ideas into beautiful SVG art through an elegant grid-and-cell system.</p> <p>The wiki should feel like opening a beautifully typeset art book, not reading API documentation. Every page should produce a visual result that makes the reader think \"I want to try that.\"</p>"},{"location":"DESIGN_FLOW/#core-principles","title":"Core Principles","text":"<ol> <li>Show, don't tell. Every concept immediately demonstrated with a rendered SVG.</li> <li>Progressive revelation. Start simple, layer complexity. Never dump everything at once.</li> <li>No dead SVGs. Every generated image must look intentional and beautiful. No empty scenes, no entities outside bounds, no \"here's a blank grid\" steps.</li> <li>Diverse examples. Vary shapes, colors, techniques. Never repeat the same pattern (e.g., \"dots dots dots\") across pages.</li> <li>The API Surface page is a destination. Users can jump there at any time for a comprehensive overview of what's possible.</li> <li>MkDocs Material maximized. Admonitions, tabbed code blocks, annotated code, grid cards, dark mode \u2014 all leveraged thoughtfully.</li> </ol>"},{"location":"DESIGN_FLOW/#target-audience","title":"Target Audience","text":"<p>Three user personas the wiki serves, in order of priority:</p> <ol> <li>The Curious Creative \u2014 Has basic Python skills. Wants to make art. Will follow tutorials.</li> <li>The Experienced Developer \u2014 Knows Python well. Wants the API surface, patterns, and architecture.</li> <li>The Contributor \u2014 Wants to extend PyFreeform. Needs entity system internals and protocols.</li> </ol> <p>Each page should serve persona 1 first (clear, visual, step-by-step), with deeper material accessible for personas 2 and 3 via admonitions, expandable sections, and dedicated reference pages.</p>"},{"location":"DESIGN_FLOW/#information-architecture","title":"Information Architecture","text":""},{"location":"DESIGN_FLOW/#navigation-structure-6-sections-down-from-10","title":"Navigation Structure (6 sections, down from 10)","text":"<pre><code>Home\n\u251c\u2500\u2500 Getting Started (3 pages)\n\u2502   \u251c\u2500\u2500 Installation\n\u2502   \u251c\u2500\u2500 Your First Artwork\n\u2502   \u2514\u2500\u2500 How PyFreeform Works\n\u251c\u2500\u2500 Guide (8 pages \u2014 the learning path)\n\u2502   \u251c\u2500\u2500 Scenes and Grids\n\u2502   \u251c\u2500\u2500 Working with Cells\n\u2502   \u251c\u2500\u2500 Drawing with Entities\n\u2502   \u251c\u2500\u2500 Colors, Styles &amp; Palettes\n\u2502   \u251c\u2500\u2500 Paths and Parametric Positioning\n\u2502   \u251c\u2500\u2500 Shapes and Polygons\n\u2502   \u251c\u2500\u2500 Text and Typography\n\u2502   \u2514\u2500\u2500 Transforms and Layout\n\u251c\u2500\u2500 Recipes (6 pages \u2014 project-based)\n\u2502   \u251c\u2500\u2500 Image-to-Art Portraits\n\u2502   \u251c\u2500\u2500 Geometric Patterns\n\u2502   \u251c\u2500\u2500 Flowing Curves &amp; Waves\n\u2502   \u251c\u2500\u2500 Connected Networks\n\u2502   \u251c\u2500\u2500 Typographic Art\n\u2502   \u2514\u2500\u2500 Advanced Compositions\n\u251c\u2500\u2500 API Surface (1 page \u2014 comprehensive reference)\n\u2502   \u2514\u2500\u2500 Complete API Reference\n\u251c\u2500\u2500 Developer Guide (3 pages \u2014 for contributors)\n\u2502   \u251c\u2500\u2500 Architecture Overview\n\u2502   \u251c\u2500\u2500 Creating Custom Entities\n\u2502   \u2514\u2500\u2500 The Pathable Protocol\n\u2514\u2500\u2500 Gallery (1 page)\n    \u2514\u2500\u2500 Showcase\n</code></pre> <p>Total: 22 pages (down from 81+ in the old wiki). Quality over quantity.</p>"},{"location":"DESIGN_FLOW/#why-this-structure","title":"Why This Structure","text":"Old Wiki Problem New Wiki Solution 10 sections, 81+ files \u2014 overwhelming navigation 6 sections, 22 pages \u2014 focused navigation Separate \"Fundamentals\" and \"Entities\" with overlap Merged into \"Guide\" with natural flow \"Advanced Concepts\" dumped many unrelated topics Split: transforms go in Guide, pathable in Guide, architecture in Developer Guide Repetitive entity pages (same pattern for each entity) Single \"Drawing with Entities\" page that covers all entities with diverse examples \"Parametric Art\" section felt academic Folded into \"Paths and Parametric Positioning\" (Guide) and \"Flowing Curves\" (Recipes) API reference spread across 8 pages Single comprehensive \"API Surface\" page \u2014 the user's explicit request Examples section disconnected from learning \"Recipes\" are self-contained projects; \"Gallery\" is a showcase"},{"location":"DESIGN_FLOW/#page-by-page-design","title":"Page-by-Page Design","text":""},{"location":"DESIGN_FLOW/#home-indexmd","title":"Home (<code>index.md</code>)","text":"<p>Purpose: Hook the user in 5 seconds. Show what's possible.</p> <p>Layout: 1. Hero section: A single stunning SVG artwork (generated, not static) with the tagline: \"Turn images into art with Python.\" 2. 3 code snippets: Each 3-4 lines, each produces a different visual. Side-by-side with their SVG output. 3. \"Choose Your Path\" cards: Getting Started (beginner), Guide (learning), Recipes (building), API Surface (reference). 4. Installation one-liner: <code>pip install pyfreeform</code></p> <p>No: Long explanations. Feature lists. Version history.</p>"},{"location":"DESIGN_FLOW/#getting-started","title":"Getting Started","text":""},{"location":"DESIGN_FLOW/#page-1-installation-getting-started01-installationmd","title":"Page 1: Installation (<code>getting-started/01-installation.md</code>)","text":"<p>Content: <code>pip install pyfreeform</code>. Verify with a 3-line \"hello world\" that produces a visible result. System requirements (Python 3.10+, Pillow).</p> <p>SVG: One small, satisfying artwork from the hello world.</p>"},{"location":"DESIGN_FLOW/#page-2-your-first-artwork-getting-started02-your-first-artworkmd","title":"Page 2: Your First Artwork (<code>getting-started/02-your-first-artwork.md</code>)","text":"<p>Content: The flagship tutorial. Two paths:</p> From an ImageFrom Scratch <p>Load MonaLisa.jpg \u2192 create scene \u2192 iterate cells \u2192 add dots by brightness \u2192 save. Build up in 3 steps, each with a rendered SVG showing progress.</p> <p><code>Scene.with_grid()</code> \u2192 iterate cells \u2192 add shapes based on position \u2192 save. Build up in 3 steps, each with a rendered SVG.</p> <p>Key teaching moments: Scene, Grid, Cell, <code>cell.brightness</code>, <code>cell.color</code>, <code>add_dot()</code>, <code>save()</code>.</p> <p>SVG count: 6 (3 per tab). Each must look good on its own \u2014 no empty grids.</p>"},{"location":"DESIGN_FLOW/#page-3-how-pyfreeform-works-getting-started03-how-it-worksmd","title":"Page 3: How PyFreeform Works (<code>getting-started/03-how-it-works.md</code>)","text":"<p>Content: Conceptual overview with a visual diagram.</p> <p>Scene \u2192 contains a Grid \u2192 divided into Cells \u2192 each cell holds image data and receives Entities (dots, lines, curves, shapes)</p> <p>Key concepts introduced (with visual for each): - The Surface protocol (cells and scenes share the same <code>add_*</code> methods) - Named positions (<code>\"center\"</code>, <code>\"top_left\"</code>, etc.) - z_index layering - The <code>along</code>/<code>t</code> parametric system (teaser)</p> <p>SVG count: 3-4 conceptual diagrams. Use annotated code blocks.</p>"},{"location":"DESIGN_FLOW/#guide-the-learning-path","title":"Guide (The Learning Path)","text":"<p>Each Guide page follows this template: 1. Opening visual: A compelling SVG that uses the page's concepts. 2. Core concept: Explained in 2-3 paragraphs with annotated code. 3. Building examples: 2-3 progressive examples, each with rendered SVG. 4. Variation showcase: A comparison table or grid showing parameter variations. 5. \"Try This\" callout: A creative challenge with a hint.</p>"},{"location":"DESIGN_FLOW/#page-1-scenes-and-grids-guide01-scenes-and-gridsmd","title":"Page 1: Scenes and Grids (<code>guide/01-scenes-and-grids.md</code>)","text":"<p>Covers: - <code>Scene.from_image()</code> \u2014 full parameter exploration (grid_size, cell_size, cell_ratio) - <code>Scene.with_grid()</code> \u2014 cols, rows, cell dimensions - Grid properties (cols, rows, pixel dimensions) - Grid selection methods: <code>grid.row()</code>, <code>grid.column()</code>, <code>grid.region()</code>, <code>grid.border()</code> - Grid pattern selections: <code>grid.every()</code>, <code>grid.checkerboard()</code>, <code>grid.where()</code>, <code>grid.diagonal()</code> - Cell merging: <code>grid.merge()</code>, <code>grid.merge_row()</code>, <code>grid.merge_col()</code></p> <p>Visuals (use both from_image and with_grid examples): - Parameter comparison: same image at different grid_size values (20, 40, 60) - Cell ratio comparison: square vs domino vs tall cells - Grid selections visualized: border cells colored, checkerboard pattern, diagonal pattern - Merged CellGroup with a title bar</p> <p>SVG count: ~8-10</p>"},{"location":"DESIGN_FLOW/#page-2-working-with-cells-guide02-working-with-cellsmd","title":"Page 2: Working with Cells (<code>guide/02-working-with-cells.md</code>)","text":"<p>Covers: - Cell data properties: <code>brightness</code>, <code>color</code>, <code>rgb</code>, <code>alpha</code> - Using brightness to drive visuals (radius, opacity, rotation, shape choice) - Named positions within a cell - Neighbor access: <code>cell.above</code>, <code>cell.right</code>, cross-cell comparisons - Sub-cell sampling: <code>sample_image()</code>, <code>sample_brightness()</code>, <code>sample_hex()</code> - <code>cell.normalized_position</code> for position-based effects - <code>cell.distance_to()</code> for radial effects</p> <p>Visuals (using MonaLisa.jpg and with_grid examples): - Brightness-to-radius mapping (classic dot art) - Brightness-to-color mapping (gradient effect) - Edge detection using neighbor comparison - Radial effect using distance_to - Sub-cell sampling for higher-detail effects</p> <p>SVG count: ~6-8</p>"},{"location":"DESIGN_FLOW/#page-3-drawing-with-entities-guide03-drawing-with-entitiesmd","title":"Page 3: Drawing with Entities (<code>guide/03-drawing-with-entities.md</code>)","text":"<p>Covers: All 8 entity types in ONE page, each demonstrated with a different creative use case (not just \"here's a dot, here's a line\").</p> <p>Structure: Short section per entity, each showing what makes that entity special:</p> <ol> <li>Dots \u2014 The fundamental mark. Example: size and opacity varying by brightness.</li> <li>Lines \u2014 Structure and direction. Example: diagonal lines showing flow direction based on brightness gradient.</li> <li>Curves \u2014 Organic flow. Example: curvature driven by brightness, creating a wave-like texture.</li> <li>Ellipses \u2014 The Pathable shape. Example: rotation driven by brightness, creating a moir\u00e9 pattern.</li> <li>Rectangles \u2014 Filled regions. Example: rotation and opacity grid creating a mosaic.</li> <li>Polygons \u2014 Shape variety. Example: different shapes per brightness band (triangles, hexagons, stars).</li> <li>Text \u2014 Labels and typography. Example: letters from the image used as dot replacements.</li> <li>Paths \u2014 Any shape imaginable. Example: spiral path rendered in each cell.</li> </ol> <p>SVG count: 8 (one per entity type), all visually distinct and compelling.</p>"},{"location":"DESIGN_FLOW/#page-4-colors-styles-palettes-guide04-colors-styles-palettesmd","title":"Page 4: Colors, Styles &amp; Palettes (<code>guide/04-colors-styles-palettes.md</code>)","text":"<p>Covers: - Color formats (named, hex, RGB) - The <code>fill=</code> vs <code>color=</code> distinction (with clear rule table) - Opacity system: <code>opacity</code>, <code>fill_opacity</code>, <code>stroke_opacity</code> - Style classes: DotStyle, LineStyle, ShapeStyle, TextStyle, etc. - The <code>.with_*()</code> builder pattern - Palettes: all 8 pre-built palettes visualized - Custom palettes, <code>with_background()</code>, <code>inverted()</code></p> <p>Visuals: - All 8 palettes applied to the same artwork (comparison grid) - Opacity layering demo - Style reuse example (define once, apply many)</p> <p>SVG count: ~6-8</p>"},{"location":"DESIGN_FLOW/#page-5-paths-and-parametric-positioning-guide05-paths-and-parametricmd","title":"Page 5: Paths and Parametric Positioning (<code>guide/05-paths-and-parametric.md</code>)","text":"<p>Covers (this is the \"aha\" page): - The <code>along</code>/<code>t</code> system: position any entity along any path - Lines as paths: <code>cell.add_dot(along=line, t=cell.brightness)</code> - Curves as paths: dots sliding along curves - Ellipses as paths: dots orbiting around ellipses - The Pathable protocol: <code>point_at(t)</code> explained visually - Custom paths: <code>add_path(pathable)</code> for Wave, Spiral, etc. - <code>align=True</code>: rotating entities to follow path tangent - Sub-paths/arcs: <code>start_t</code>/<code>end_t</code> for partial paths - TextPath: text warped along curves and ellipses</p> <p>Visuals: - Dot sliding along a line (brightness-driven position) - Dots along a curve vs dots along an ellipse (comparison) - Spiral path rendered with varying colors - Text warped along a curve - Multiple t-values visualized on a single path</p> <p>SVG count: ~8-10</p>"},{"location":"DESIGN_FLOW/#page-6-shapes-and-polygons-guide06-shapes-and-polygonsmd","title":"Page 6: Shapes and Polygons (<code>guide/06-shapes-and-polygons.md</code>)","text":"<p>Covers: - Polygon shape classmethods: <code>triangle()</code>, <code>hexagon()</code>, <code>star()</code>, <code>squircle()</code>, etc. - Using shapes in cells: <code>cell.add_polygon(Polygon.hexagon(), fill=cell.color)</code> - Shape comparison gallery - EntityGroup: composing custom reusable shapes - Factory function pattern for EntityGroups - <code>group.fit_to_cell()</code> and <code>entity.fit_within()</code></p> <p>Visuals: - All 8 shape classmethods in a comparison grid - Hexagonal grid using <code>add_polygon(Polygon.hexagon())</code> - Star pattern with brightness-driven size - EntityGroup \"flower\" pattern reused across cells - fit_to_cell demonstration with rotation</p> <p>SVG count: ~6-8</p>"},{"location":"DESIGN_FLOW/#page-7-text-and-typography-guide07-text-and-typographymd","title":"Page 7: Text and Typography (<code>guide/07-text-and-typography.md</code>)","text":"<p>Covers: - Basic text placement: <code>add_text(\"A\", color=cell.color)</code> - Font families, bold/italic - Text alignment: <code>text_anchor</code>, <code>baseline</code> - Rotation and positioning - <code>fit_within()</code> for fitting text inside shapes - TextPath: text along curves, ellipses, custom paths - Auto-sizing behavior - <code>start_offset</code> / <code>end_offset</code> for partial path warping</p> <p>Visuals: - Character grid from image (each cell shows a letter sized by brightness) - Text along curve comparison - Bold vs italic vs monospace showcase - Title overlaid on artwork using merged CellGroup</p> <p>SVG count: ~5-7</p>"},{"location":"DESIGN_FLOW/#page-8-transforms-and-layout-guide08-transforms-and-layoutmd","title":"Page 8: Transforms and Layout (<code>guide/08-transforms-and-layout.md</code>)","text":"<p>Covers: - <code>entity.rotate()</code>, <code>entity.scale()</code> - <code>entity.move_to()</code>, <code>entity.move_by()</code>, <code>entity.translate()</code> - <code>entity.fit_to_cell(scale, recenter, at)</code> \u2014 the auto-fitting system - <code>entity.fit_within(target)</code> \u2014 fit inside another entity - <code>entity.place_beside(other, side, gap)</code> \u2014 relative positioning - <code>entity.offset_from(anchor, dx, dy)</code> \u2014 anchor-based positioning - Connections: <code>entity.connect()</code> with styles - The anchor system: named anchors per entity type - z_index layering: controlling draw order - <code>map_range()</code> utility</p> <p>Visuals: - Rotation grid (shapes rotated by position) - Scale comparison (same shape at different scales) - fit_to_cell with different <code>at=</code> positions - Connected network of entities - Layered composition using z_index</p> <p>SVG count: ~6-8</p>"},{"location":"DESIGN_FLOW/#recipes-project-based","title":"Recipes (Project-Based)","text":"<p>Recipes are self-contained \"build this\" projects. Each produces a complete, impressive artwork.</p> <p>Template: Goal \u2192 Setup \u2192 Build (3-5 steps) \u2192 Variations \u2192 Complete code.</p>"},{"location":"DESIGN_FLOW/#recipe-1-image-to-art-portraits-recipes01-image-to-artmd","title":"Recipe 1: Image-to-Art Portraits (<code>recipes/01-image-to-art.md</code>)","text":"<p>Using MonaLisa.jpg and FrankMonster.png: - Classic dot art (brightness \u2192 radius) - Color dot art (preserve original colors) - Halftone effect (brightness \u2192 size, dark background) - Line art variant (diagonal lines, brightness \u2192 width)</p> <p>SVG count: ~6 (technique comparisons using real images)</p>"},{"location":"DESIGN_FLOW/#recipe-2-geometric-patterns-recipes02-geometric-patternsmd","title":"Recipe 2: Geometric Patterns (<code>recipes/02-geometric-patterns.md</code>)","text":"<p>Using <code>Scene.with_grid()</code>: - Checkerboard with shape variations - Rotating hexagonal tiling - Brightness-wave pattern (sine function driving shape properties) - Islamic-geometry-inspired pattern using stars and connections</p> <p>SVG count: ~5</p>"},{"location":"DESIGN_FLOW/#recipe-3-flowing-curves-waves-recipes03-flowing-curvesmd","title":"Recipe 3: Flowing Curves &amp; Waves (<code>recipes/03-flowing-curves.md</code>)","text":"<ul> <li>Curve field (curves connecting neighbors)</li> <li>Wave visualization using custom Pathable</li> <li>Spiral paths with varying density</li> <li>MCEscher-inspired flowing pattern using MCEscherBirds.jpg</li> </ul> <p>SVG count: ~5</p>"},{"location":"DESIGN_FLOW/#recipe-4-connected-networks-recipes04-connected-networksmd","title":"Recipe 4: Connected Networks (<code>recipes/04-connected-networks.md</code>)","text":"<ul> <li>Connecting bright dots to their neighbors</li> <li>Distance-based connection filtering</li> <li>Arrow-cap directed graphs</li> <li>Network overlay on image</li> </ul> <p>SVG count: ~4</p>"},{"location":"DESIGN_FLOW/#recipe-5-typographic-art-recipes05-typographic-artmd","title":"Recipe 5: Typographic Art (<code>recipes/05-typographic-art.md</code>)","text":"<ul> <li>ASCII art: character per cell based on brightness</li> <li>Text along paths: curved titles and labels</li> <li>TextPath on ellipses</li> <li>Combined: image art with text overlay</li> </ul> <p>SVG count: ~4</p>"},{"location":"DESIGN_FLOW/#recipe-6-advanced-compositions-recipes06-advanced-compositionsmd","title":"Recipe 6: Advanced Compositions (<code>recipes/06-advanced-compositions.md</code>)","text":"<ul> <li>Multi-layer artwork (z_index orchestration)</li> <li>EntityGroup reusable motifs</li> <li>CellGroup merged regions with different treatments</li> <li>Combined techniques: image + geometry + text + connections</li> </ul> <p>SVG count: ~4</p>"},{"location":"DESIGN_FLOW/#api-surface-api-surfaceindexmd","title":"API Surface (<code>api-surface/index.md</code>)","text":"<p>This is the API_SURFACE.md document, reformatted for the wiki with proper MkDocs Material features: - Tabbed sections for quick navigation - Collapsible details for verbose signatures - Syntax-highlighted code examples - Cross-links to relevant Guide pages</p> <p>Single comprehensive page covering the entire API. The user explicitly requested this.</p>"},{"location":"DESIGN_FLOW/#developer-guide","title":"Developer Guide","text":""},{"location":"DESIGN_FLOW/#page-1-architecture-overview-developer-guide01-architecturemd","title":"Page 1: Architecture Overview (<code>developer-guide/01-architecture.md</code>)","text":"<ul> <li>Module structure diagram</li> <li>Surface protocol explained</li> <li>Entity class hierarchy</li> <li>SVG rendering pipeline (Scene.to_svg flow)</li> </ul>"},{"location":"DESIGN_FLOW/#page-2-creating-custom-entities-developer-guide02-creating-entitiesmd","title":"Page 2: Creating Custom Entities (<code>developer-guide/02-creating-entities.md</code>)","text":"<ul> <li>Implementing the Entity abstract class</li> <li>Required methods: <code>anchor()</code>, <code>anchor_names</code>, <code>to_svg()</code>, <code>bounds()</code></li> <li>Optional: <code>inner_bounds()</code>, <code>get_required_markers()</code>, <code>get_required_paths()</code></li> <li>Example: creating a custom \"Arrowhead\" entity</li> </ul>"},{"location":"DESIGN_FLOW/#page-3-the-pathable-protocol-developer-guide03-pathable-protocolmd","title":"Page 3: The Pathable Protocol (<code>developer-guide/03-pathable-protocol.md</code>)","text":"<ul> <li>The protocol interface: <code>point_at(t)</code> + optional <code>arc_length()</code>, <code>angle_at(t)</code>, <code>to_svg_path_d()</code></li> <li>Creating custom pathables (Wave, Spiral, Lissajous examples)</li> <li>How <code>add_path()</code> converts pathables to smooth SVG</li> <li>The cubic Bezier fitting algorithm explained</li> </ul>"},{"location":"DESIGN_FLOW/#gallery-galleryindexmd","title":"Gallery (<code>gallery/index.md</code>)","text":"<p>A visual showcase grid of the best SVGs generated across all pages. Each links to its source page/recipe.</p>"},{"location":"DESIGN_FLOW/#svg-generation-system","title":"SVG Generation System","text":""},{"location":"DESIGN_FLOW/#design-principles","title":"Design Principles","text":"<ol> <li>One generator per page (not per image). Each generator produces all SVGs for its page.</li> <li>Pathlib everywhere. No <code>os.path</code>.</li> <li>Common utilities: Shared helper module for colors, saving, and image loading.</li> <li>Explicit output paths: Every SVG path is clearly derived from the page name.</li> <li>No internal attribute access: Never use <code>cell._brightness</code> \u2014 always use <code>cell.brightness</code>.</li> <li>Validation: Each generator validates its outputs exist and are non-empty.</li> </ol>"},{"location":"DESIGN_FLOW/#directory-structure","title":"Directory Structure","text":"<pre><code>wiki/\n\u251c\u2500\u2500 index.md\n\u251c\u2500\u2500 mkdocs.yml            # (or symlink from project root)\n\u251c\u2500\u2500 sample_images/\n\u2502   \u251c\u2500\u2500 FrankMonster.png\n\u2502   \u251c\u2500\u2500 MonaLisa.jpg\n\u2502   \u2514\u2500\u2500 MCEscherBirds.jpg\n\u251c\u2500\u2500 _generator/\n\u2502   \u251c\u2500\u2500 __init__.py       # Common utilities\n\u2502   \u251c\u2500\u2500 generate_all.py   # Master runner\n\u2502   \u251c\u2500\u2500 getting_started/\n\u2502   \u2502   \u251c\u2500\u2500 gen_02_first_artwork.py\n\u2502   \u2502   \u2514\u2500\u2500 gen_03_how_it_works.py\n\u2502   \u251c\u2500\u2500 guide/\n\u2502   \u2502   \u251c\u2500\u2500 gen_01_scenes_and_grids.py\n\u2502   \u2502   \u251c\u2500\u2500 gen_02_working_with_cells.py\n\u2502   \u2502   \u251c\u2500\u2500 gen_03_drawing_with_entities.py\n\u2502   \u2502   \u251c\u2500\u2500 gen_04_colors_styles_palettes.py\n\u2502   \u2502   \u251c\u2500\u2500 gen_05_paths_and_parametric.py\n\u2502   \u2502   \u251c\u2500\u2500 gen_06_shapes_and_polygons.py\n\u2502   \u2502   \u251c\u2500\u2500 gen_07_text_and_typography.py\n\u2502   \u2502   \u2514\u2500\u2500 gen_08_transforms_and_layout.py\n\u2502   \u251c\u2500\u2500 recipes/\n\u2502   \u2502   \u251c\u2500\u2500 gen_01_image_to_art.py\n\u2502   \u2502   \u251c\u2500\u2500 gen_02_geometric_patterns.py\n\u2502   \u2502   \u251c\u2500\u2500 gen_03_flowing_curves.py\n\u2502   \u2502   \u251c\u2500\u2500 gen_04_connected_networks.py\n\u2502   \u2502   \u251c\u2500\u2500 gen_05_typographic_art.py\n\u2502   \u2502   \u2514\u2500\u2500 gen_06_advanced_compositions.py\n\u2502   \u2514\u2500\u2500 home/\n\u2502       \u2514\u2500\u2500 gen_index.py\n\u251c\u2500\u2500 _images/              # All generated SVGs go here\n\u2502   \u251c\u2500\u2500 home/\n\u2502   \u251c\u2500\u2500 getting-started/\n\u2502   \u251c\u2500\u2500 guide/\n\u2502   \u251c\u2500\u2500 recipes/\n\u2502   \u2514\u2500\u2500 gallery/\n\u251c\u2500\u2500 getting-started/\n\u2502   \u251c\u2500\u2500 01-installation.md\n\u2502   \u251c\u2500\u2500 02-your-first-artwork.md\n\u2502   \u2514\u2500\u2500 03-how-it-works.md\n\u251c\u2500\u2500 guide/\n\u2502   \u251c\u2500\u2500 01-scenes-and-grids.md\n\u2502   \u251c\u2500\u2500 02-working-with-cells.md\n\u2502   \u251c\u2500\u2500 03-drawing-with-entities.md\n\u2502   \u251c\u2500\u2500 04-colors-styles-palettes.md\n\u2502   \u251c\u2500\u2500 05-paths-and-parametric.md\n\u2502   \u251c\u2500\u2500 06-shapes-and-polygons.md\n\u2502   \u251c\u2500\u2500 07-text-and-typography.md\n\u2502   \u2514\u2500\u2500 08-transforms-and-layout.md\n\u251c\u2500\u2500 recipes/\n\u2502   \u251c\u2500\u2500 01-image-to-art.md\n\u2502   \u251c\u2500\u2500 02-geometric-patterns.md\n\u2502   \u251c\u2500\u2500 03-flowing-curves.md\n\u2502   \u251c\u2500\u2500 04-connected-networks.md\n\u2502   \u251c\u2500\u2500 05-typographic-art.md\n\u2502   \u2514\u2500\u2500 06-advanced-compositions.md\n\u251c\u2500\u2500 api-surface/\n\u2502   \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 developer-guide/\n\u2502   \u251c\u2500\u2500 01-architecture.md\n\u2502   \u251c\u2500\u2500 02-creating-entities.md\n\u2502   \u2514\u2500\u2500 03-pathable-protocol.md\n\u2514\u2500\u2500 gallery/\n    \u2514\u2500\u2500 index.md\n</code></pre>"},{"location":"DESIGN_FLOW/#generator-common-utilities-_generator__init__py","title":"Generator Common Utilities (<code>_generator/__init__.py</code>)","text":"<pre><code>\"\"\"Common utilities for wiki SVG generators.\"\"\"\nfrom pathlib import Path\n\nWIKI_ROOT = Path(__file__).parent.parent\nIMAGES_DIR = WIKI_ROOT / \"_images\"\nSAMPLE_IMAGES = WIKI_ROOT / \"sample_images\"\n\ndef save(scene, path: str) -&gt; Path:\n    \"\"\"Save scene to _images/ directory. Returns the output path.\"\"\"\n    output = IMAGES_DIR / path\n    output.parent.mkdir(parents=True, exist_ok=True)\n    scene.save(str(output))\n    assert output.exists(), f\"Failed to generate: {output}\"\n    assert output.stat().st_size &gt; 100, f\"Suspiciously small file: {output}\"\n    return output\n\ndef sample_image(name: str) -&gt; Path:\n    \"\"\"Get path to a sample image.\"\"\"\n    path = SAMPLE_IMAGES / name\n    assert path.exists(), f\"Sample image not found: {path}\"\n    return path\n</code></pre>"},{"location":"DESIGN_FLOW/#generator-runner-_generatorgenerate_allpy","title":"Generator Runner (<code>_generator/generate_all.py</code>)","text":"<pre><code>\"\"\"Regenerate all SVGs for wiki.\"\"\"\nimport importlib\nimport sys\nfrom pathlib import Path\n\nGENERATORS_DIR = Path(__file__).parent\n\ndef discover_generators():\n    \"\"\"Find all gen_*.py files.\"\"\"\n    return sorted(GENERATORS_DIR.rglob(\"gen_*.py\"))\n\ndef run_all():\n    \"\"\"Run all generators, report results.\"\"\"\n    generators = discover_generators()\n    print(f\"Found {len(generators)} generators\")\n\n    passed, failed = 0, 0\n    for gen_path in generators:\n        module_path = gen_path.relative_to(GENERATORS_DIR.parent)\n        module_name = str(module_path).replace(\"/\", \".\").replace(\"\\\\\", \".\").removesuffix(\".py\")\n\n        try:\n            module = importlib.import_module(module_name)\n            if hasattr(module, \"generate\"):\n                module.generate()\n            passed += 1\n            print(f\"  OK  {gen_path.name}\")\n        except Exception as e:\n            failed += 1\n            print(f\"  FAIL {gen_path.name}: {e}\")\n\n    print(f\"\\n{passed} passed, {failed} failed out of {len(generators)}\")\n    return failed == 0\n\nif __name__ == \"__main__\":\n    success = run_all()\n    sys.exit(0 if success else 1)\n</code></pre>"},{"location":"DESIGN_FLOW/#example-generator-_generatorguidegen_01_scenes_and_gridspy","title":"Example Generator (<code>_generator/guide/gen_01_scenes_and_grids.py</code>)","text":"<pre><code>\"\"\"Generate SVGs for Guide: Scenes and Grids.\"\"\"\nfrom pyfreeform import Scene, Palette\nfrom _generator import save, sample_image\n\ndef generate():\n    # --- Grid size comparison ---\n    for grid_size in [20, 40, 60]:\n        scene = Scene.from_image(\n            sample_image(\"MonaLisa.jpg\"),\n            grid_size=grid_size,\n        )\n        for cell in scene.grid:\n            cell.add_dot(\n                radius=cell.brightness * scene.grid.cell_width * 0.45,\n                color=cell.color,\n            )\n        save(scene, f\"guide/scenes-grid-size-{grid_size}.svg\")\n\n    # --- Cell ratio comparison ---\n    for ratio, label in [(1.0, \"square\"), (2.0, \"domino\"), (0.5, \"tall\")]:\n        scene = Scene.from_image(\n            sample_image(\"MonaLisa.jpg\"),\n            grid_size=30,\n            cell_ratio=ratio,\n        )\n        for cell in scene.grid:\n            cell.add_fill(color=cell.color)\n        save(scene, f\"guide/scenes-ratio-{label}.svg\")\n\n    # --- Border selection ---\n    scene = Scene.with_grid(cols=15, rows=15, cell_size=20)\n    palette = Palette.midnight()\n    for cell in scene.grid:\n        cell.add_fill(color=palette.background)\n    for cell in scene.grid.border(thickness=2):\n        cell.add_fill(color=palette.accent)\n    save(scene, \"guide/scenes-border-selection.svg\")\n\n    # ... more examples\n</code></pre>"},{"location":"DESIGN_FLOW/#mkdocs-material-features-used","title":"MkDocs Material Features Used","text":""},{"location":"DESIGN_FLOW/#theme-configuration","title":"Theme Configuration","text":"<pre><code>theme:\n  name: material\n  palette:\n    - scheme: default\n      primary: deep purple\n      accent: amber\n      toggle: { icon: material/brightness-7, name: Switch to dark mode }\n    - scheme: slate\n      primary: deep purple\n      accent: amber\n      toggle: { icon: material/brightness-4, name: Switch to light mode }\n  features:\n    - navigation.instant\n    - navigation.tracking\n    - navigation.tabs        # Top-level sections as tabs\n    - navigation.sections    # Expand sections in sidebar\n    - navigation.top         # Back to top button\n    - navigation.indexes     # Section index pages\n    - search.suggest\n    - search.highlight\n    - content.code.copy      # Copy buttons on code blocks\n    - content.code.annotate  # Code annotations\n    - content.tabs.link      # Linked tabs (same tab selection across page)\n    - toc.follow\n</code></pre>"},{"location":"DESIGN_FLOW/#markdown-features-used-per-page","title":"Markdown Features Used Per Page","text":"Feature Usage Admonitions <code>!!! tip</code>, <code>!!! info</code>, <code>!!! warning</code> for callouts Expandable details <code>??? note \"Advanced\"</code> for deep dives Tabbed code <code>=== \"From Image\"</code> / <code>=== \"From Scratch\"</code> Annotated code <code># (1)!</code> with annotation below Image comparison Side-by-side SVGs in grid layout Tables Parameter comparisons, style references Grid cards Home page \"choose your path\" Glightbox Click to zoom on SVGs"},{"location":"DESIGN_FLOW/#image-embedding-pattern","title":"Image Embedding Pattern","text":"<pre><code>&lt;figure markdown&gt;\n  ![Dot art from MonaLisa](_images/guide/dot-art-mona-lisa.svg){ width=\"400\" }\n  &lt;figcaption&gt;Brightness-driven dot sizes reveal the portrait&lt;/figcaption&gt;\n&lt;/figure&gt;\n</code></pre> <p>For side-by-side comparison: </p><pre><code>&lt;div class=\"grid\" markdown&gt;\n\n![Grid size 20](_images/guide/scenes-grid-size-20.svg){ width=\"280\" }\n\n![Grid size 40](_images/guide/scenes-grid-size-40.svg){ width=\"280\" }\n\n![Grid size 60](_images/guide/scenes-grid-size-60.svg){ width=\"280\" }\n\n&lt;/div&gt;\n</code></pre><p></p>"},{"location":"DESIGN_FLOW/#sample-image-strategy","title":"Sample Image Strategy","text":""},{"location":"DESIGN_FLOW/#provided-images","title":"Provided Images","text":"Image Use Why MonaLisa.jpg Primary tutorial image Iconic, high contrast, universally recognized FrankMonster.png Secondary tutorial image Fun, colorful, different aesthetic from Mona Lisa MCEscherBirds.jpg Advanced examples Detailed, pattern-rich, good for flowing curves and edge detection"},{"location":"DESIGN_FLOW/#usage-rules","title":"Usage Rules","text":"<ul> <li>MonaLisa: Getting Started tutorial, Recipes: Image-to-Art, Guide: Working with Cells</li> <li>FrankMonster: Guide: Drawing with Entities, Recipes: Image-to-Art (alternate)</li> <li>MCEscher: Recipes: Flowing Curves, Guide: Paths (advanced examples)</li> <li>Each image used in at most 3 pages to avoid repetition</li> <li>Most Guide pages use <code>Scene.with_grid()</code> (no image) for clarity and focus</li> </ul>"},{"location":"DESIGN_FLOW/#custom-sample-images-to-create","title":"Custom Sample Images (To Create)","text":"<p>We should create 2-3 additional simple images specifically designed to showcase <code>from_image()</code> well:</p> <ol> <li>gradient.png \u2014 A smooth color gradient (great for demonstrating brightness-driven effects clearly)</li> <li>circles.png \u2014 Simple geometric circles on a dark background (demonstrates edge detection, high-contrast effects)</li> </ol> <p>These can be generated programmatically with Pillow and placed in <code>sample_images/</code>.</p>"},{"location":"DESIGN_FLOW/#build-order","title":"Build Order","text":"<p>The implementation should proceed in this order:</p>"},{"location":"DESIGN_FLOW/#phase-1-foundation","title":"Phase 1: Foundation","text":"<ol> <li>Set up directory structure</li> <li>Create <code>_generator/__init__.py</code> with utilities</li> <li>Create <code>_generator/generate_all.py</code> runner</li> <li>Create custom sample images (gradient.png, circles.png)</li> <li>Create <code>mkdocs.yml</code> configuration</li> </ol>"},{"location":"DESIGN_FLOW/#phase-2-core-pages","title":"Phase 2: Core Pages","text":"<ol> <li>Home page (<code>index.md</code>) with hero SVG generator</li> <li>Getting Started: Installation</li> <li>Getting Started: Your First Artwork (with generator)</li> <li>Getting Started: How PyFreeform Works (with generator)</li> </ol>"},{"location":"DESIGN_FLOW/#phase-3-guide","title":"Phase 3: Guide","text":"<ol> <li>Guide pages 1-8, each with its generator<ul> <li>Build in order, as later pages reference earlier concepts</li> </ul> </li> </ol>"},{"location":"DESIGN_FLOW/#phase-4-recipes","title":"Phase 4: Recipes","text":"<ol> <li>Recipes 1-6, each with its generator<ul> <li>Can be built in any order</li> </ul> </li> </ol>"},{"location":"DESIGN_FLOW/#phase-5-reference-meta","title":"Phase 5: Reference &amp; Meta","text":"<ol> <li>API Surface page (adapt API_SURFACE.md)</li> <li>Developer Guide pages</li> <li>Gallery page (collects best SVGs from all generators)</li> </ol>"},{"location":"DESIGN_FLOW/#phase-6-polish","title":"Phase 6: Polish","text":"<ol> <li>Cross-link all pages</li> <li>Run full regeneration, verify all SVGs</li> <li>Dark mode testing</li> <li>Final navigation refinement</li> </ol>"},{"location":"DESIGN_FLOW/#quality-checklist-per-page","title":"Quality Checklist (per page)","text":"<ul> <li>[ ] Every SVG renders correctly and looks intentional</li> <li>[ ] No empty/blank SVGs (every image shows meaningful content)</li> <li>[ ] No entities rendering outside scene bounds</li> <li>[ ] Code examples are complete and correct (can be copy-pasted)</li> <li>[ ] Examples are diverse (no two examples on the same page produce similar-looking output)</li> <li>[ ] MkDocs features used appropriately (not overloaded)</li> <li>[ ] Cross-links to related pages where relevant</li> <li>[ ] Tested in both light and dark mode</li> <li>[ ] Each page can stand alone (no required reading order, though recommended)</li> <li>[ ] Progressive: simple \u2192 complex within each page</li> </ul>"},{"location":"DESIGN_FLOW/#estimated-svg-count","title":"Estimated SVG Count","text":"Section Pages SVGs per Page Total SVGs Home 1 4 4 Getting Started 3 4 12 Guide 8 7 56 Recipes 6 5 30 API Surface 1 0 0 Developer Guide 3 2 6 Gallery 1 12 12 Total 23 \u2014 ~120 <p>Down from 224+ SVGs in the old wiki, but each one is intentional and beautiful.</p>"},{"location":"api-surface/","title":"API Surface","text":""},{"location":"api-surface/#api-reference","title":"API Reference","text":"<p>This is the comprehensive API reference for PyFreeform v0.3.0. Every class, method, property, and concept is documented here on a single page, organized to follow the natural discovery flow -- from creating your first Scene to building complex generative art.</p> <p>How to use this reference</p> <p>This page is designed as a lookup reference. For learning-oriented walkthroughs with visual examples, see the Guide section. For copy-paste starting points, see Recipes.</p>"},{"location":"api-surface/#1-the-entry-point-scene","title":"1. The Entry Point: Scene","text":"<p>Everything starts with a <code>Scene</code>. It is the canvas -- it holds your artwork and renders it to SVG.</p> <p>See also</p> <p>For a hands-on walkthrough of creating scenes, see Scenes and Grids.</p>"},{"location":"api-surface/#three-ways-to-create-a-scene","title":"Three Ways to Create a Scene","text":"Constructor Use Case Returns <code>Scene(width, height, background=None)</code> Manual canvas, no grid Scene <code>Scene.from_image(source, *, grid_size=40, cell_size=10, ...)</code> Image-based art Scene with grid <code>Scene.with_grid(*, cols=30, rows=None, cell_size=10, ...)</code> Grid-based art, no image Scene with grid <p><code>Scene.from_image()</code> is the flagship -- load a photo, get a grid where every cell knows the color and brightness of the pixel it overlays.</p> <p><code>Scene.with_grid()</code> gives you the same grid structure but with no image data (cells default to brightness 0.5, color \"#808080\").</p> <p><code>Scene(w, h)</code> is for freeform art -- you place entities at absolute positions, no grid involved.</p>"},{"location":"api-surface/#scene-properties","title":"Scene Properties","text":"Property Type Description <code>scene.width</code> <code>int</code> Canvas width in pixels <code>scene.height</code> <code>int</code> Canvas height in pixels <code>scene.background</code> <code>str \\| None</code> Background color (default: <code>\"#1a1a2e\"</code> midnight blue) <code>scene.grid</code> <code>Grid</code> The primary grid (raises <code>ValueError</code> if none) <code>scene.grids</code> <code>list[Grid]</code> All grids in the scene <code>scene.entities</code> <code>list[Entity]</code> All entities (including those inside grid cells) <code>scene.connections</code> <code>list[Connection]</code> All connections"},{"location":"api-surface/#scene-methods","title":"Scene Methods","text":"Method Description <code>scene.add(*objects)</code> Add entities, connections, or grids. Returns last added. <code>scene.remove(obj)</code> Remove an object. Returns <code>True</code> if found. <code>scene.clear()</code> Remove everything. <code>scene.to_svg()</code> Render to SVG string. <code>scene.save(path)</code> Save to <code>.svg</code> file (adds extension if missing)."},{"location":"api-surface/#from_image-full-signature","title":"<code>from_image()</code> Full Signature","text":"Expand full signature <pre><code>Scene.from_image(\n    source: str | Path | Image,   # File path or Image object\n    *,\n    grid_size: int | None = 40,   # Columns (rows auto from aspect ratio)\n    cell_size: int = 10,          # Base cell size in pixels\n    cell_ratio: float = 1.0,      # Width-to-height ratio (2.0 = domino)\n    cell_width: float | None,     # Explicit cell width (overrides cell_size)\n    cell_height: float | None,    # Explicit cell height (overrides cell_size)\n    background: str | None,       # Background color (default \"#1a1a2e\")\n) -&gt; Scene\n</code></pre> <p>Two modes:</p> <ul> <li><code>grid_size=N</code> (default): N columns, rows calculated from image aspect ratio. Scene dimensions = grid * cell_size.</li> <li><code>grid_size=None</code>: Grid fits the image dimensions. Columns/rows derived from <code>image.width / cell_size</code>.</li> </ul>"},{"location":"api-surface/#with_grid-full-signature","title":"<code>with_grid()</code> Full Signature","text":"Expand full signature <pre><code>Scene.with_grid(\n    *,\n    cols: int = 30,               # Columns\n    rows: int | None = None,      # Rows (defaults to cols for square)\n    cell_size: int = 10,          # Base cell size in pixels\n    cell_width: float | None,     # Explicit cell width\n    cell_height: float | None,    # Explicit cell height\n    background: str | None,       # Background color (default \"#1a1a2e\")\n) -&gt; Scene\n</code></pre>"},{"location":"api-surface/#2-the-grid-structure-and-selection","title":"2. The Grid: Structure and Selection","text":"<p>A <code>Grid</code> divides the scene into rows and columns of <code>Cell</code> objects. It provides powerful selection methods for targeting specific cells.</p> <p>See also</p> <p>For grid creation patterns and cell access techniques, see Scenes and Grids.</p>"},{"location":"api-surface/#grid-construction","title":"Grid Construction","text":"Constructor Description <code>Grid(cols, rows, cell_size=None, cell_width=None, cell_height=None)</code> Manual grid <code>Grid.from_image(image, cols=None, rows=None, cell_size=10, ...)</code> Grid sized to image"},{"location":"api-surface/#grid-properties","title":"Grid Properties","text":"Property Type Description <code>grid.cols</code> <code>int</code> Number of columns <code>grid.rows</code> <code>int</code> Number of rows <code>grid.cell_width</code> <code>float</code> Cell width in pixels <code>grid.cell_height</code> <code>float</code> Cell height in pixels <code>grid.cell_size</code> <code>(float, float)</code> <code>(cell_width, cell_height)</code> tuple <code>grid.pixel_width</code> <code>float</code> Total width = cols * cell_width <code>grid.pixel_height</code> <code>float</code> Total height = rows * cell_height <code>grid.origin</code> <code>Point</code> Top-left corner position <code>grid.source_image</code> <code>Image \\| None</code> Original source image (if from_image)"},{"location":"api-surface/#cell-access","title":"Cell Access","text":"Operation Description <code>grid[row, col]</code> Access by (row, col) index <code>for cell in grid:</code> Iterate row-by-row, left-to-right <code>len(grid)</code> Total number of cells <code>grid.cell_at(x, y)</code> Get cell at pixel position (or None)"},{"location":"api-surface/#row-column-access","title":"Row &amp; Column Access","text":"Method Returns Description <code>grid.row(i)</code> <code>list[Cell]</code> All cells in row i <code>grid.column(i)</code> <code>list[Cell]</code> All cells in column i <code>grid.all_rows</code> <code>Iterator[list[Cell]]</code> Iterate over all rows <code>grid.all_columns</code> <code>Iterator[list[Cell]]</code> Iterate over all columns"},{"location":"api-surface/#region-selection","title":"Region Selection","text":"Method Returns Description <code>grid.region(row_start, row_end, col_start, col_end)</code> <code>Iterator[Cell]</code> Rectangular region <code>grid.border(thickness=1)</code> <code>Iterator[Cell]</code> Cells on the grid border"},{"location":"api-surface/#cell-merging-cellgroup","title":"Cell Merging (CellGroup)","text":"Method Returns Description <code>grid.merge(row_start, row_end, col_start, col_end)</code> <code>CellGroup</code> Merge region into single surface <code>grid.merge_row(i)</code> <code>CellGroup</code> Merge full row <code>grid.merge_col(i)</code> <code>CellGroup</code> Merge full column <p>A <code>CellGroup</code> is a virtual surface -- it has all the same <code>add_*</code> builder methods as a Cell, and averaged data properties from its constituent cells.</p>"},{"location":"api-surface/#pattern-selection","title":"Pattern Selection","text":"Method Description <code>grid.every(n, offset=0)</code> Every Nth cell (linear count) <code>grid.checkerboard(\"black\" \\| \"white\")</code> Checkerboard pattern <code>grid.where(predicate)</code> Filter by lambda: <code>grid.where(lambda c: c.brightness &gt; 0.5)</code> <code>grid.diagonal(direction=\"down\", offset=0)</code> Main or offset diagonals"},{"location":"api-surface/#data-loading","title":"Data Loading","text":"<pre><code>grid.load_layer(name, source, mode=\"value\")\n</code></pre> <p>Modes: <code>\"value\"</code> (raw), <code>\"normalized\"</code> (0-1), <code>\"hex\"</code> (color string). Normally handled automatically by <code>Scene.from_image()</code>.</p>"},{"location":"api-surface/#3-the-cell-your-creative-unit","title":"3. The Cell: Your Creative Unit","text":"<p><code>Cell</code> extends <code>Surface</code> -- it inherits all 12+ builder methods plus has image data, position helpers, and neighbor access.</p> <p>See also</p> <p>For practical cell usage patterns, see Working with Cells.</p>"},{"location":"api-surface/#typed-data-properties-from-loaded-image","title":"Typed Data Properties (from loaded image)","text":"Property Type Default Description <code>cell.brightness</code> <code>float</code> <code>0.5</code> 0.0 (black) to 1.0 (white) <code>cell.color</code> <code>str</code> <code>\"#808080\"</code> Hex color string <code>cell.rgb</code> <code>(int, int, int)</code> <code>(128, 128, 128)</code> RGB tuple (0-255 each) <code>cell.alpha</code> <code>float</code> <code>1.0</code> 0.0 (transparent) to 1.0 (opaque) <code>cell.data</code> <code>dict</code> <code>{}</code> Raw data dict for custom layers"},{"location":"api-surface/#position-properties-inherited-from-surface","title":"Position Properties (inherited from Surface)","text":"Property Type Description <code>cell.x</code>, <code>cell.y</code> <code>float</code> Top-left corner <code>cell.width</code>, <code>cell.height</code> <code>float</code> Cell dimensions <code>cell.bounds</code> <code>(x, y, w, h)</code> Bounding tuple <code>cell.center</code> <code>Point</code> Center position <code>cell.top_left</code> <code>Point</code> Top-left corner <code>cell.top_right</code> <code>Point</code> Top-right corner <code>cell.bottom_left</code> <code>Point</code> Bottom-left corner <code>cell.bottom_right</code> <code>Point</code> Bottom-right corner"},{"location":"api-surface/#grid-position","title":"Grid Position","text":"Property Type Description <code>cell.row</code> <code>int</code> Row index (0-based) <code>cell.col</code> <code>int</code> Column index (0-based) <code>cell.grid</code> <code>Grid</code> Parent grid <code>cell.normalized_position</code> <code>(float, float)</code> (nx, ny) normalized to 0.0-1.0 within grid"},{"location":"api-surface/#neighbors","title":"Neighbors","text":"Property Returns Direction <code>cell.above</code> <code>Cell \\| None</code> North <code>cell.below</code> <code>Cell \\| None</code> South <code>cell.left</code> <code>Cell \\| None</code> West <code>cell.right</code> <code>Cell \\| None</code> East <code>cell.above_left</code> <code>Cell \\| None</code> Northwest <code>cell.above_right</code> <code>Cell \\| None</code> Northeast <code>cell.below_left</code> <code>Cell \\| None</code> Southwest <code>cell.below_right</code> <code>Cell \\| None</code> Southeast <code>cell.neighbors</code> <code>dict[str, Cell \\| None]</code> 4 cardinal directions <code>cell.neighbors_all</code> <code>dict[str, Cell \\| None]</code> All 8 directions <p>Neighbor properties return Cells, not positions</p> <p><code>cell.left</code>, <code>cell.right</code>, <code>cell.above</code>, <code>cell.below</code> return <code>Cell | None</code>, not position coordinates. Use <code>cell.center</code>, <code>cell.top_left</code>, etc. for positions.</p>"},{"location":"api-surface/#sub-cell-image-sampling","title":"Sub-Cell Image Sampling","text":"<p>For finer-grained access to the original source image within a cell's area:</p> Method Returns Description <code>cell.sample_image(rx, ry)</code> <code>(int, int, int)</code> RGB at relative position within cell <code>cell.sample_brightness(rx, ry)</code> <code>float</code> Brightness at relative position <code>cell.sample_hex(rx, ry)</code> <code>str</code> Hex color at relative position <p>Where <code>rx</code> and <code>ry</code> are 0.0-1.0 within the cell (0.5, 0.5 = center).</p>"},{"location":"api-surface/#utility","title":"Utility","text":"Method Returns Description <code>cell.distance_to(other)</code> <code>float</code> Pixel distance to Cell, Point, or tuple"},{"location":"api-surface/#4-the-surface-protocol-builder-methods","title":"4. The Surface Protocol: Builder Methods","text":"<p><code>Surface</code> is the base class for <code>Cell</code>, <code>Scene</code>, and <code>CellGroup</code>. It provides 12 builder methods that all work identically across these three surfaces.</p> <p>See also</p> <p>For creative examples of all builder methods, see Drawing with Entities.</p>"},{"location":"api-surface/#named-positions","title":"Named Positions","text":"<p>All <code>at</code> parameters accept named positions or <code>(rx, ry)</code> relative coordinates:</p> Name Relative Description <code>\"center\"</code> <code>(0.5, 0.5)</code> Center of surface <code>\"top_left\"</code> <code>(0.0, 0.0)</code> Top-left corner <code>\"top_right\"</code> <code>(1.0, 0.0)</code> Top-right corner <code>\"bottom_left\"</code> <code>(0.0, 1.0)</code> Bottom-left corner <code>\"bottom_right\"</code> <code>(1.0, 1.0)</code> Bottom-right corner <code>\"top\"</code> <code>(0.5, 0.0)</code> Top center <code>\"bottom\"</code> <code>(0.5, 1.0)</code> Bottom center <code>\"left\"</code> <code>(0.0, 0.5)</code> Left center <code>\"right\"</code> <code>(1.0, 0.5)</code> Right center"},{"location":"api-surface/#parametric-positioning-along-t-align","title":"Parametric Positioning: <code>along</code> / <code>t</code> / <code>align</code>","text":"<p>All builder methods (except <code>add_fill</code>, <code>add_border</code>) support parametric positioning:</p> <ul> <li><code>along</code>: Any <code>Pathable</code> object (Line, Curve, Ellipse, Path, Connection, or custom)</li> <li><code>t</code>: Parameter 0.0 (start) to 1.0 (end) along the path</li> <li><code>align</code>: If <code>True</code>, rotate the entity to follow the path's tangent direction</li> </ul> <p>Killer feature</p> <p>This is PyFreeform's most powerful concept -- position any element along any path: </p><pre><code>line = cell.add_diagonal()\ncell.add_dot(along=line, t=cell.brightness)  # Dot slides along diagonal\n</code></pre> See Paths and Parametric Positioning for in-depth examples.<p></p>"},{"location":"api-surface/#complete-builder-reference","title":"Complete Builder Reference","text":""},{"location":"api-surface/#add_dot","title":"<code>add_dot</code>","text":"<pre><code>add_dot(*, at, along, t, radius=5, color=\"black\", z_index=0, opacity=1.0, style=DotStyle)\n</code></pre> <p>Creates a filled circle. Default position: center.</p>"},{"location":"api-surface/#add_line","title":"<code>add_line</code>","text":"<pre><code>add_line(*, start, end, along, t, align, width=1, color=\"black\", z_index=0,\n         cap=\"round\", start_cap, end_cap, opacity=1.0, style=LineStyle)\n</code></pre> <p>Creates a line segment. Default: center to center (zero-length).</p>"},{"location":"api-surface/#add_diagonal","title":"<code>add_diagonal</code>","text":"<pre><code>add_diagonal(*, start=\"bottom_left\", end=\"top_right\", along, t, align, width=1,\n             color=\"black\", z_index=0, cap=\"round\", start_cap, end_cap,\n             opacity=1.0, style=LineStyle)\n</code></pre> <p>Convenience for corner-to-corner lines. Delegates to <code>add_line()</code>.</p>"},{"location":"api-surface/#add_curve","title":"<code>add_curve</code>","text":"<pre><code>add_curve(*, start=\"bottom_left\", end=\"top_right\", curvature=0.5, along, t, align,\n          width=1, color=\"black\", z_index=0, cap=\"round\", start_cap, end_cap,\n          opacity=1.0, style=LineStyle)\n</code></pre> <p>Creates a quadratic Bezier curve. <code>curvature</code>: 0 = straight, positive = bows left, negative = bows right.</p>"},{"location":"api-surface/#add_path","title":"<code>add_path</code>","text":"Expand full signature <pre><code>add_path(pathable, *, segments=64, closed=False, start_t=0.0, end_t=1.0,\n         width=1, color=\"black\", fill=None, z_index=0, cap=\"round\",\n         start_cap, end_cap, opacity=1.0, fill_opacity, stroke_opacity,\n         style=LineStyle)\n</code></pre> <p>Renders any Pathable as a smooth SVG <code>&lt;path&gt;</code> using cubic Bezier approximation. Supports arcs via <code>start_t</code>/<code>end_t</code>, closed paths with fill, and dual opacity.</p>"},{"location":"api-surface/#add_ellipse","title":"<code>add_ellipse</code>","text":"Expand full signature <pre><code>add_ellipse(*, at, along, t, align, rx, ry, rotation=0, fill=\"black\",\n            stroke=None, stroke_width=1, z_index=0, opacity=1.0,\n            fill_opacity, stroke_opacity, style=ShapeStyle)\n</code></pre> <p>Creates an ellipse. Default radii: 40% of surface dimensions. The ellipse itself is a Pathable -- you can position other elements along it.</p>"},{"location":"api-surface/#add_polygon","title":"<code>add_polygon</code>","text":"Expand full signature <pre><code>add_polygon(vertices, *, along, t, align, fill=\"black\", stroke=None,\n            stroke_width=1, z_index=0, opacity=1.0, fill_opacity,\n            stroke_opacity, rotation=0, style=ShapeStyle)\n</code></pre> <p>Creates a polygon from relative-coordinate vertices (0-1). Use <code>Polygon.hexagon()</code>, <code>Polygon.star()</code>, etc. for common shapes. See Shapes and Polygons for shape classmethods.</p>"},{"location":"api-surface/#add_rect","title":"<code>add_rect</code>","text":"Expand full signature <pre><code>add_rect(*, at, along, t, align, width, height, rotation=0, fill=\"black\",\n         stroke=None, stroke_width=1, opacity=1.0, fill_opacity,\n         stroke_opacity, z_index=0, style=ShapeStyle)\n</code></pre> <p>Creates a rectangle. <code>at</code> specifies the center position. Default size: 60% of surface.</p>"},{"location":"api-surface/#add_text","title":"<code>add_text</code>","text":"Expand full signature <pre><code>add_text(content, *, at, along, t, align, font_size, color=\"black\",\n         font_family=\"sans-serif\", bold=False, italic=False, text_anchor,\n         baseline=\"middle\", rotation=0, z_index=0, opacity=1.0,\n         start_offset=0.0, end_offset=1.0, style=TextStyle)\n</code></pre> <p>Creates text. Two modes with <code>along</code>:</p> <ul> <li><code>along</code> + <code>t</code>: Position text at a point on the path, optionally align to tangent.</li> <li><code>along</code> without <code>t</code>: Warp text along the path using SVG <code>&lt;textPath&gt;</code> (auto-sizes font to fill path).</li> </ul> <p>See Text and Typography for text layout techniques.</p>"},{"location":"api-surface/#add_fill","title":"<code>add_fill</code>","text":"<pre><code>add_fill(*, color=\"black\", opacity=1.0, z_index=0, style=FillStyle)\n</code></pre> <p>Fill the entire surface with a solid color.</p>"},{"location":"api-surface/#add_border","title":"<code>add_border</code>","text":"<pre><code>add_border(*, color=\"#cccccc\", width=0.5, z_index=0, opacity=1.0, style=BorderStyle)\n</code></pre> <p>Add a stroke-only border around the surface.</p>"},{"location":"api-surface/#place-add_entity","title":"<code>place</code> / <code>add_entity</code>","text":"<pre><code>place(entity, at=\"center\")\nadd_entity(entity, at=\"center\")\n</code></pre> <p>Place an existing entity into this surface. Works for any entity type including <code>EntityGroup</code>.</p>"},{"location":"api-surface/#5-entities-the-drawing-primitives","title":"5. Entities: The Drawing Primitives","text":"<p>All entities inherit from <code>Entity</code> and share these common capabilities.</p> <p>See also</p> <p>For creative examples of each entity type, see Drawing with Entities.</p>"},{"location":"api-surface/#entity-base-class","title":"Entity Base Class","text":"Property/Method Description <code>entity.position</code> Current position (<code>Point</code>) <code>entity.x</code>, <code>entity.y</code> Position coordinates <code>entity.z_index</code> Layer ordering (higher = on top) <code>entity.cell</code> Containing Surface (if placed) <code>entity.connections</code> Set of connections involving this entity <code>entity.data</code> Custom data dictionary"},{"location":"api-surface/#movement","title":"Movement","text":"Method Description <code>entity.move_to(x, y)</code> Move to absolute position <code>entity.move_by(dx, dy)</code> Move by relative offset <code>entity.translate(dx, dy)</code> Alias for <code>move_by()</code> <code>entity.move_to_cell(cell, at=\"center\")</code> Move to position within a cell"},{"location":"api-surface/#transforms","title":"Transforms","text":"Method Description <code>entity.rotate(angle, origin=None)</code> Rotate in degrees (counterclockwise) <code>entity.scale(factor, origin=None)</code> Scale (2.0 = double size) <code>entity.fit_to_cell(scale=1.0, recenter=True, *, at=None)</code> Auto-scale to fit within containing cell <code>entity.fit_within(target, scale=1.0, recenter=True, *, at=None)</code> Auto-scale to fit within another entity's inner bounds <p>See Transforms and Layout for detailed transform examples.</p>"},{"location":"api-surface/#relationships","title":"Relationships","text":"Method Description <code>entity.connect(other, style, start_anchor, end_anchor)</code> Create a Connection to another entity <code>entity.anchor(name)</code> Get named anchor point <code>entity.anchor_names</code> List of available anchor names <code>entity.offset_from(anchor_name, dx, dy)</code> Point offset from an anchor <code>entity.place_beside(other, side=\"right\", gap=0)</code> Position beside another entity using bounding boxes"},{"location":"api-surface/#abstract-methods-implemented-by-each-entity-type","title":"Abstract Methods (implemented by each entity type)","text":"Method Description <code>entity.to_svg()</code> Render to SVG element string <code>entity.bounds()</code> Bounding box: <code>(min_x, min_y, max_x, max_y)</code> <code>entity.inner_bounds()</code> Inscribed rectangle (default: same as bounds)"},{"location":"api-surface/#5a-dot","title":"5a. Dot","text":"<p>A filled circle. The simplest entity.</p> <pre><code>Dot(x=0, y=0, radius=5, color=\"black\", z_index=0, opacity=1.0)\n</code></pre> <ul> <li>Anchors: <code>\"center\"</code></li> <li><code>color=</code> parameter (not <code>fill=</code>)</li> <li><code>inner_bounds()</code> returns inscribed square</li> </ul>"},{"location":"api-surface/#5b-line","title":"5b. Line","text":"<p>A line segment between two points. Implements the Pathable protocol.</p> <pre><code>Line(x1, y1, x2, y2, width=1, color=\"black\", z_index=0, cap=\"round\",\n     start_cap=None, end_cap=None, opacity=1.0)\nLine.from_points(start, end, ...)\n</code></pre> <ul> <li>Anchors: <code>\"start\"</code>, <code>\"center\"</code>, <code>\"end\"</code></li> <li>Pathable: <code>line.point_at(t)</code> returns a point along the line</li> <li>Properties: <code>line.start</code>, <code>line.end</code>, <code>line.length</code></li> <li>Methods: <code>line.set_endpoints(start, end)</code>, <code>line.arc_length()</code>, <code>line.angle_at(t)</code>, <code>line.to_svg_path_d()</code></li> <li>Cap values: <code>\"round\"</code>, <code>\"square\"</code>, <code>\"butt\"</code>, <code>\"arrow\"</code>, <code>\"arrow_in\"</code></li> </ul>"},{"location":"api-surface/#5c-curve","title":"5c. Curve","text":"<p>A quadratic Bezier curve. Implements the Pathable protocol.</p> <pre><code>Curve(x1, y1, x2, y2, curvature=0.5, width=1, color=\"black\", z_index=0,\n      cap=\"round\", start_cap=None, end_cap=None, opacity=1.0)\nCurve.from_points(start, end, curvature=0.5, ...)\n</code></pre> <ul> <li>Anchors: <code>\"start\"</code>, <code>\"center\"</code>, <code>\"end\"</code>, <code>\"control\"</code></li> <li>Pathable: <code>curve.point_at(t)</code> returns a point along the Bezier curve</li> <li>Curvature: 0 = straight, positive = bows left, negative = bows right, typical range -1 to 1</li> <li>Properties: <code>curve.start</code>, <code>curve.end</code>, <code>curve.curvature</code>, <code>curve.control</code></li> <li>Methods: <code>curve.arc_length()</code>, <code>curve.angle_at(t)</code>, <code>curve.to_svg_path_d()</code></li> </ul> <p>See Paths and Parametric Positioning for Bezier curve techniques.</p>"},{"location":"api-surface/#5d-ellipse","title":"5d. Ellipse","text":"<p>An ellipse (oval). Implements the Pathable protocol.</p> <pre><code>Ellipse(x, y, rx=10, ry=10, rotation=0, fill=\"black\", stroke=None,\n        stroke_width=1, z_index=0, opacity=1.0, fill_opacity=None, stroke_opacity=None)\nEllipse.at_center(center, rx, ry, ...)\n</code></pre> <ul> <li>Anchors: <code>\"center\"</code>, <code>\"right\"</code>, <code>\"top\"</code>, <code>\"left\"</code>, <code>\"bottom\"</code></li> <li>Pathable: <code>ellipse.point_at(t)</code> -- t=0 rightmost, t=0.25 top, t=0.5 left, t=0.75 bottom</li> <li><code>fill=</code> parameter (not <code>color=</code>)</li> <li>Dual opacity: <code>fill_opacity</code> and <code>stroke_opacity</code> override <code>opacity</code></li> <li>Methods: <code>point_at_angle(degrees)</code>, <code>arc_length()</code>, <code>angle_at(t)</code>, <code>to_svg_path_d()</code>, <code>inner_bounds()</code></li> </ul>"},{"location":"api-surface/#5e-polygon","title":"5e. Polygon","text":"<p>A closed polygon from vertices. Includes shape classmethods for common shapes.</p> <pre><code>Polygon(vertices, fill=\"black\", stroke=None, stroke_width=1, z_index=0,\n        opacity=1.0, fill_opacity=None, stroke_opacity=None)\n</code></pre> <ul> <li>Anchors: <code>\"center\"</code> + <code>\"v0\"</code>, <code>\"v1\"</code>, <code>\"v2\"</code>, ...</li> <li><code>fill=</code> parameter (not <code>color=</code>)</li> <li>Dual opacity: <code>fill_opacity</code> and <code>stroke_opacity</code></li> <li>Position is centroid of vertices</li> </ul> <p>See also</p> <p>For all shape classmethods and polygon techniques, see Shapes and Polygons.</p>"},{"location":"api-surface/#shape-classmethods","title":"Shape Classmethods","text":"<p>All return <code>list[tuple[float, float]]</code> in relative coordinates (0-1), ready for <code>add_polygon()</code>:</p> Method Description <code>Polygon.triangle(size=1.0, center=(0.5, 0.5))</code> Equilateral triangle (pointing up) <code>Polygon.square(size=0.8, center=(0.5, 0.5))</code> Axis-aligned square <code>Polygon.diamond(size=0.8, center=(0.5, 0.5))</code> Rotated square (45 degrees) <code>Polygon.hexagon(size=0.8, center=(0.5, 0.5))</code> Regular hexagon <code>Polygon.star(points=5, size=0.8, inner_ratio=0.4, center=(0.5, 0.5))</code> Star with N points <code>Polygon.regular_polygon(sides, size=0.8, center=(0.5, 0.5))</code> Regular N-gon <code>Polygon.squircle(size=0.8, center=(0.5, 0.5), n=4, points=32)</code> Superellipse (n=2 circle, n=4 squircle) <code>Polygon.rounded_rect(size=0.8, center=(0.5, 0.5), corner_radius=0.2, points_per_corner=8)</code> Rectangle with rounded corners"},{"location":"api-surface/#5f-rect","title":"5f. Rect","text":"<p>A rectangle with optional rotation.</p> <pre><code>Rect(x, y, width, height, fill=\"black\", stroke=None, stroke_width=1,\n     rotation=0, z_index=0, opacity=1.0, fill_opacity=None, stroke_opacity=None)\nRect.at_center(center, width, height, rotation=0, ...)\n</code></pre> <ul> <li>Anchors: <code>\"center\"</code>, <code>\"top_left\"</code>, <code>\"top_right\"</code>, <code>\"bottom_left\"</code>, <code>\"bottom_right\"</code>, <code>\"top\"</code>, <code>\"bottom\"</code>, <code>\"left\"</code>, <code>\"right\"</code></li> <li><code>fill=</code> parameter (not <code>color=</code>)</li> <li>Dual opacity: <code>fill_opacity</code> and <code>stroke_opacity</code></li> <li><code>x, y</code> is top-left corner; <code>Rect.at_center()</code> positions by center</li> <li>Rotation: stored as <code>rotation</code> attribute, emits SVG <code>transform=\"rotate()\"</code></li> <li>Rotation-aware anchors (anchors account for rotation angle)</li> </ul>"},{"location":"api-surface/#5g-text","title":"5g. Text","text":"<p>A text label with rich formatting.</p> Expand full constructor <pre><code>Text(x=0, y=0, content=\"\", font_size=16, color=\"black\",\n     font_family=\"sans-serif\", font_style=\"normal\", font_weight=\"normal\",\n     bold=False, italic=False, text_anchor=\"middle\", baseline=\"middle\",\n     rotation=0, z_index=0, opacity=1.0)\n</code></pre> <ul> <li>Anchors: <code>\"center\"</code></li> <li><code>color=</code> parameter</li> <li>Sugar: <code>bold=True</code> sets <code>font_weight=\"bold\"</code>, <code>italic=True</code> sets <code>font_style=\"italic\"</code></li> <li>Text alignment: <code>text_anchor</code> = <code>\"start\"</code> / <code>\"middle\"</code> / <code>\"end\"</code>, <code>baseline</code> = <code>\"auto\"</code> / <code>\"middle\"</code> / <code>\"hanging\"</code> / etc.</li> <li>Rotation: <code>rotation</code> attribute, SVG <code>transform=\"rotate()\"</code></li> <li>Bounds: Uses Pillow for accurate font measurement; heuristic fallback</li> <li>TextPath: <code>text.set_textpath(path_id, path_d, start_offset, text_length)</code> for warping along paths</li> </ul> <p>See Text and Typography for text layout and textpath examples.</p>"},{"location":"api-surface/#5h-path","title":"5h. Path","text":"<p>Renders any Pathable as a smooth SVG path. Implements the Pathable protocol itself.</p> Expand full constructor <pre><code>Path(\n    pathable,           # Any object with point_at(t)\n    *,\n    segments=64,        # Number of cubic Bezier segments\n    closed=False,       # Close path smoothly (enables fill)\n    start_t=0.0,        # Start parameter (for arcs/sub-paths)\n    end_t=1.0,          # End parameter (for arcs/sub-paths)\n    width=1,            # Stroke width\n    color=\"black\",      # Stroke color\n    fill=None,          # Fill color (only if closed)\n    z_index=0,\n    cap=\"round\",\n    start_cap=None,\n    end_cap=None,\n    opacity=1.0,\n    fill_opacity=None,\n    stroke_opacity=None,\n)\n</code></pre> <ul> <li>Anchors: <code>\"start\"</code>, <code>\"center\"</code>, <code>\"end\"</code></li> <li>Pathable: <code>path.point_at(t)</code> evaluates the stored Bezier segments</li> <li>Algorithm: Hermite interpolation to cubic Bezier fitting with C1 continuity</li> <li>Sub-paths: Use <code>start_t</code>/<code>end_t</code> to render a portion of any path (e.g., quarter of an ellipse)</li> <li>Methods: <code>arc_length()</code>, <code>angle_at(t)</code>, <code>to_svg_path_d()</code></li> </ul> <p>See Paths and Parametric Positioning for path rendering techniques.</p>"},{"location":"api-surface/#5i-entitygroup","title":"5i. EntityGroup","text":"<p>A reusable composite entity. Children positioned relative to (0,0), rendered as SVG <code>&lt;g&gt;</code>.</p> <pre><code>EntityGroup(x=0, y=0, z_index=0)\n</code></pre> <ul> <li><code>group.add(entity)</code>: Add child (positioned relative to local origin)</li> <li><code>group.children</code>: List of children (copy)</li> <li><code>group._scale</code>: Internal scale factor, modified by <code>scale()</code></li> <li>Placement: <code>cell.place(group)</code> / <code>cell.add_entity(group)</code> -- centers in cell</li> <li>Fitting: <code>group.fit_to_cell(fraction)</code> -- auto-scales to fit cell bounds</li> <li>SVG: <code>&lt;g transform=\"translate(x,y) scale(s)\"&gt;</code> -- children never mutated</li> <li>Reuse: Wrap creation in a factory function; each call returns new instance</li> </ul> <p>EntityGroup vs CellGroup</p> <p><code>EntityGroup</code> inherits <code>Entity</code> and is used for reusable composite shapes. <code>CellGroup</code> inherits <code>Surface</code> and represents merged multi-cell regions. They serve different purposes.</p> <p>See Transforms and Layout for EntityGroup composition patterns.</p>"},{"location":"api-surface/#6-the-pathable-protocol","title":"6. The Pathable Protocol","text":"<p>The <code>Pathable</code> protocol defines a single method:</p> <pre><code>class Pathable:\n    def point_at(self, t: float) -&gt; Point\n</code></pre> <p>Where <code>t</code> ranges from 0.0 (start) to 1.0 (end). This enables the <code>along</code>/<code>t</code> parametric positioning system.</p> <p>See also</p> <p>For a deep dive into parametric positioning, see Paths and Parametric Positioning.</p>"},{"location":"api-surface/#built-in-pathables","title":"Built-in Pathables","text":"Entity Description <code>Line</code> Linear interpolation start to end <code>Curve</code> Quadratic Bezier <code>Ellipse</code> Parametric ellipse (t=0 right, t=0.25 top, t=0.5 left, t=0.75 bottom) <code>Path</code> Evaluates stored cubic Bezier segments <code>Connection</code> Dynamic path between entities"},{"location":"api-surface/#optional-pathable-methods","title":"Optional Pathable Methods","text":"<p>These methods enable additional features when present:</p> Method Used By Description <code>arc_length()</code> <code>add_text(along=)</code> Total path length for text sizing <code>angle_at(t)</code> <code>get_angle_at()</code> Tangent angle for alignment <code>to_svg_path_d()</code> <code>add_text(along=)</code> SVG path for <code>&lt;textPath&gt;</code> warping"},{"location":"api-surface/#custom-pathables","title":"Custom Pathables","text":"<p>Any object with <code>point_at(t: float) -&gt; Point</code> works:</p> <pre><code>class Wave:\n    def point_at(self, t):\n        x = self.start.x + t * (self.end.x - self.start.x)\n        y = self.center_y + self.amplitude * math.sin(t * self.frequency * 2 * math.pi)\n        return Point(x, y)\n</code></pre>"},{"location":"api-surface/#7-connections","title":"7. Connections","text":"<p>Links between entities that auto-update when entities move.</p> <pre><code>Connection(start, end, start_anchor=\"center\", end_anchor=\"center\", style=None)\n</code></pre> <p>Or via the entity method: </p><pre><code>connection = entity1.connect(\n    entity2,\n    style=ConnectionStyle(...),\n    start_anchor=\"center\",\n    end_anchor=\"center\"\n)\n</code></pre><p></p> <ul> <li><code>style</code> accepts <code>ConnectionStyle</code> or <code>dict</code> with <code>width</code>, <code>color</code>, <code>z_index</code>, <code>cap</code> keys</li> <li>Connections are rendered as lines between anchor points</li> <li>Added to scene via <code>scene.add(connection)</code> (entity.connect() does not auto-add)</li> <li>Support cap system (arrow, arrow_in, custom)</li> </ul> <p>Connections must be added to the scene</p> <p>Calling <code>entity.connect(other)</code> creates a <code>Connection</code> object but does not add it to the scene. You must call <code>scene.add(connection)</code> separately.</p>"},{"location":"api-surface/#8-transforms-and-fitting","title":"8. Transforms and Fitting","text":"<p>See also</p> <p>For hands-on transform examples including <code>fit_to_cell</code> and <code>fit_within</code>, see Transforms and Layout.</p>"},{"location":"api-surface/#entity-transforms","title":"Entity Transforms","text":"<p>All entities support:</p> <ul> <li><code>rotate(angle, origin)</code> -- Degrees counterclockwise. Default origin varies by entity type.</li> <li><code>scale(factor, origin)</code> -- 2.0 = double size. Scales both geometry and position.</li> </ul> <p>Each entity type handles transforms appropriately:</p> <ul> <li>Dot: Scales radius</li> <li>Line/Curve: Rotates/scales both endpoints</li> <li>Ellipse: Scales radii, updates intrinsic rotation</li> <li>Polygon: Transforms all vertices</li> <li>Text: Scales font_size</li> <li>Path: Transforms all Bezier control points</li> <li>EntityGroup: Accumulates internal <code>_scale</code> factor</li> </ul>"},{"location":"api-surface/#fit_to_cellscale10-recentertrue-atnone","title":"<code>fit_to_cell(scale=1.0, recenter=True, *, at=None)</code>","text":"<p>Auto-scales and positions any entity to fit within its containing cell.</p> <ul> <li><code>scale</code>: Fraction of cell to fill (0.0-1.0). Default 1.0 fills entire cell.</li> <li><code>recenter</code>: If True, centers in cell after scaling.</li> <li><code>at=(rx, ry)</code>: Position-aware mode. Entity is placed at relative position within cell, with available space constrained by nearest edges.</li> </ul>"},{"location":"api-surface/#fit_withintarget-scale10-recentertrue-atnone","title":"<code>fit_within(target, scale=1.0, recenter=True, *, at=None)</code>","text":"<p>Same concept, but fits within another entity's <code>inner_bounds()</code> instead of the cell.</p>"},{"location":"api-surface/#9-color-and-styling","title":"9. Color and Styling","text":"<p>See also</p> <p>For creative styling techniques and palette usage, see Colors, Styles, and Palettes.</p>"},{"location":"api-surface/#the-color-parameter-split","title":"The Color Parameter Split","text":"<p>Critical API distinction: <code>fill=</code> vs <code>color=</code></p> <p>This is the most common source of errors. Using the wrong parameter will raise a <code>TypeError</code>.</p> Parameter Used by Entity property <code>color=</code> Dot, Line, Curve, Text, add_dot, add_line, add_curve, add_text, add_fill, add_border, all style classes <code>.color</code> <code>fill=</code> Rect, Ellipse, Polygon, add_rect, add_ellipse, add_polygon, Path (for closed paths) <code>.fill</code> <p><code>ShapeStyle.color</code> maps to <code>fill=</code> when applied to shapes.</p>"},{"location":"api-surface/#color-formats","title":"Color Formats","text":"<p>The <code>Color</code> utility accepts:</p> <ul> <li>Named colors: <code>\"red\"</code>, <code>\"coral\"</code>, <code>\"navy\"</code>, etc.</li> <li>Hex: <code>\"#ff0000\"</code>, <code>\"#f00\"</code>, <code>\"#FF0000\"</code></li> <li>RGB tuple: <code>(255, 0, 0)</code></li> </ul>"},{"location":"api-surface/#opacity-system","title":"Opacity System","text":"<ul> <li><code>opacity</code> on every entity and style: 0.0 (transparent) to 1.0 (opaque). Default 1.0 emits no SVG attribute.</li> <li><code>fill_opacity</code> / <code>stroke_opacity</code> on shapes (Rect, Ellipse, Polygon, Path, ShapeStyle): optional overrides for independent control.</li> <li>Simple entities (Dot, Line, Curve, Text, Connection): SVG <code>opacity</code> attribute.</li> <li>Shapes: SVG <code>fill-opacity</code> + <code>stroke-opacity</code> attributes.</li> </ul>"},{"location":"api-surface/#style-classes","title":"Style Classes","text":"<p>7 immutable dataclasses with <code>.with_*()</code> builder methods:</p> Class For Key Fields <code>DotStyle</code> <code>add_dot()</code> <code>radius</code>, <code>color</code>, <code>z_index</code>, <code>opacity</code> <code>LineStyle</code> <code>add_line()</code>, <code>add_diagonal()</code>, <code>add_curve()</code>, <code>add_path()</code> <code>width</code>, <code>color</code>, <code>z_index</code>, <code>cap</code>, <code>start_cap</code>, <code>end_cap</code>, <code>opacity</code> <code>FillStyle</code> <code>add_fill()</code> <code>color</code>, <code>opacity</code>, <code>z_index</code> <code>BorderStyle</code> <code>add_border()</code> <code>width</code>, <code>color</code>, <code>z_index</code>, <code>opacity</code> <code>ShapeStyle</code> <code>add_ellipse()</code>, <code>add_polygon()</code>, <code>add_rect()</code> <code>color</code>, <code>stroke</code>, <code>stroke_width</code>, <code>z_index</code>, <code>opacity</code>, <code>fill_opacity</code>, <code>stroke_opacity</code> <code>TextStyle</code> <code>add_text()</code> <code>font_size</code>, <code>color</code>, <code>font_family</code>, <code>bold</code>, <code>italic</code>, <code>text_anchor</code>, <code>baseline</code>, <code>rotation</code>, <code>z_index</code>, <code>opacity</code> <code>ConnectionStyle</code> <code>Connection</code>, <code>entity.connect()</code> <code>width</code>, <code>color</code>, <code>z_index</code>, <code>cap</code>, <code>start_cap</code>, <code>end_cap</code>, <code>opacity</code> <p>Example builder pattern: </p><pre><code>base_style = LineStyle(width=2, color=\"coral\")\nthick_style = base_style.with_width(4)\narrow_style = base_style.with_end_cap(\"arrow\")\n</code></pre><p></p>"},{"location":"api-surface/#palettes","title":"Palettes","text":"<p>8 pre-built color palettes with 6 named colors each:</p> Palette Background Vibe <code>Palette.midnight()</code> <code>#1a1a2e</code> Dark blue with coral accent <code>Palette.sunset()</code> <code>#2d1b4e</code> Warm oranges and purples <code>Palette.ocean()</code> <code>#0a1628</code> Cool blues and teals <code>Palette.forest()</code> <code>#1a2e1a</code> Natural greens and earth <code>Palette.monochrome()</code> <code>#0a0a0a</code> Black, white, grays <code>Palette.paper()</code> <code>#fafafa</code> Light, clean, minimalist <code>Palette.neon()</code> <code>#0d0d0d</code> Vibrant neon electric <code>Palette.pastel()</code> <code>#fef6e4</code> Soft, gentle pastels <p>Named colors: <code>background</code>, <code>primary</code>, <code>secondary</code>, <code>accent</code>, <code>line</code>, <code>grid</code>.</p> <p>Methods: <code>with_background(color)</code>, <code>inverted()</code>, <code>all_colors()</code>, iteration.</p>"},{"location":"api-surface/#10-cap-system","title":"10. Cap System","text":"<p>Line/Curve/Connection endpoints support custom caps:</p> Built-in Cap Description <code>\"round\"</code> Standard SVG round cap <code>\"square\"</code> SVG square cap <code>\"butt\"</code> SVG butt cap (flat) <code>\"arrow\"</code> Arrowhead marker at endpoint <code>\"arrow_in\"</code> Inward-pointing arrowhead <p>Per-end caps: <code>start_cap</code> and <code>end_cap</code> override the base <code>cap</code>: </p><pre><code>cell.add_line(start=\"left\", end=\"right\", cap=\"round\", end_cap=\"arrow\")\n</code></pre><p></p> <p>Custom caps via registry: </p><pre><code>from pyfreeform import register_cap\nregister_cap(\"diamond\", my_diamond_generator)\n</code></pre><p></p>"},{"location":"api-surface/#11-the-point-type","title":"11. The Point Type","text":"<pre><code>from pyfreeform import Point\n</code></pre> <p><code>Point</code> is a <code>NamedTuple</code> with <code>x</code> and <code>y</code> fields. Subscriptable: <code>point[0]</code>, <code>point[1]</code>.</p> Method Description <code>Point(x, y)</code> Create a point <code>point.x</code>, <code>point.y</code> Access coordinates <code>point[0]</code>, <code>point[1]</code> Subscript access <code>point.distance_to(other)</code> Euclidean distance <code>point.midpoint(other)</code> Midpoint between two points <code>point.lerp(other, t)</code> Linear interpolation <code>point + Point(dx, dy)</code> Addition <code>point - Point(dx, dy)</code> Subtraction"},{"location":"api-surface/#12-image-processing","title":"12. Image Processing","text":""},{"location":"api-surface/#image-class","title":"Image Class","text":"<pre><code>from pyfreeform import Image\nimage = Image.load(\"photo.jpg\")\n</code></pre> Method/Property Description <code>Image.load(path)</code> Load from file <code>Image.from_pil(pil_image)</code> Create from PIL Image <code>image.width</code>, <code>image.height</code> Dimensions <code>image.has_alpha</code> Whether image has alpha channel <code>image[\"brightness\"]</code> Get brightness Layer <code>image[\"red\"]</code>, <code>[\"green\"]</code>, <code>[\"blue\"]</code>, <code>[\"alpha\"]</code> Channel layers <code>image.rgb_at(x, y)</code> RGB at pixel position <code>image.hex_at(x, y)</code> Hex color at pixel position <code>image.resize(width, height)</code> Resize image <code>image.fit(max_dim)</code> Fit within max dimension <code>image.quantize(levels)</code> Reduce to N levels <code>image.downscale(factor)</code> Downscale by factor <p>See also</p> <p>For image-to-art workflows, see Image to Art.</p>"},{"location":"api-surface/#layer-class","title":"Layer Class","text":"<p>A single-channel grayscale array (used for brightness, individual color channels, etc.):</p> Property/Method Description <code>layer.width</code>, <code>layer.height</code> Dimensions <code>layer[x, y]</code> Value at position (0-255)"},{"location":"api-surface/#13-utility-functions","title":"13. Utility Functions","text":""},{"location":"api-surface/#map_rangevalue-in_min0-in_max1-out_min0-out_max1-clampfalse","title":"<code>map_range(value, in_min=0, in_max=1, out_min=0, out_max=1, clamp=False)</code>","text":"<p>Map a value from one range to another. Convenience for creative coding.</p> <pre><code>from pyfreeform import map_range\n\nrotation = map_range(cell.brightness, 0, 1, 0, 360)\nradius = map_range(cell.brightness, 0, 1, 2, 10)\n</code></pre>"},{"location":"api-surface/#get_angle_atpathable-t","title":"<code>get_angle_at(pathable, t)</code>","text":"<p>Compute the tangent angle at parameter <code>t</code> on a Pathable. Used internally by the <code>align</code> system.</p> <pre><code>from pyfreeform import get_angle_at\nangle = get_angle_at(curve, 0.5)  # Angle in degrees at midpoint\n</code></pre>"},{"location":"api-surface/#displayscene_or_svg","title":"<code>display(scene_or_svg)</code>","text":"<p>Display an SVG in the current environment (Jupyter notebook, etc.).</p>"},{"location":"api-surface/#14-relationship-map","title":"14. Relationship Map","text":"<pre><code>Scene \u2500\u2500has\u2500\u2500&gt; Grid \u2500\u2500has\u2500\u2500&gt; Cell (Surface)\n  |              |              |\n  | (Surface)    | selections   | builder methods\n  | add_*()      | .where()     | add_dot(), add_line(), ...\n  |              | .border()    |\n  |              | .merge() \u2500\u2500&gt; CellGroup (Surface)\n  |              |\n  | add()        | from_image() loads Image\n  v              v\nEntity &lt;\u2500\u2500 Dot, Line, Curve, Ellipse, Polygon, Rect, Text, Path, EntityGroup\n  |\n  | connect()\n  v\nConnection\n  |\n  | Pathable protocol: point_at(t)\n  v\nLine, Curve, Ellipse, Path, Connection  &lt;\u2500\u2500 any custom class with point_at(t)\n</code></pre>"},{"location":"api-surface/#key-design-principles","title":"Key Design Principles","text":"<ol> <li>Surface protocol: Cell, Scene, CellGroup all share identical <code>add_*</code> methods</li> <li>Pathable protocol: Position anything along anything with <code>along</code>/<code>t</code></li> <li><code>fill=</code> vs <code>color=</code>: Shapes use <code>fill</code>, everything else uses <code>color</code></li> <li>Immutable styles: Style classes with <code>.with_*()</code> builder methods</li> <li>z_index layering: Higher values render on top, same values preserve add-order</li> <li>Everything returns self: Transform methods chain: <code>entity.rotate(45).scale(0.5).move_by(10, 0)</code></li> </ol>"},{"location":"developer-guide/","title":"Developer Guide","text":""},{"location":"developer-guide/#developer-guide","title":"Developer Guide","text":"<p>For contributors and developers who want to extend PyFreeform.</p> Page Covers Architecture Overview Module structure, Surface protocol, rendering pipeline Creating Custom Entities Implementing the Entity abstract class The Pathable Protocol Creating custom parametric paths"},{"location":"developer-guide/01-architecture/","title":"Architecture Overview","text":""},{"location":"developer-guide/01-architecture/#architecture-overview","title":"Architecture Overview","text":"<p>This page covers the internal structure of PyFreeform -- how modules are organized, how entities relate to surfaces, and how SVG rendering works end to end.</p>"},{"location":"developer-guide/01-architecture/#module-structure","title":"Module Structure","text":"<pre><code>pyfreeform/\n  core/           # Foundational abstractions\n    entity.py       # Entity ABC -- base for all drawable objects\n    surface.py      # Surface base class -- Cell, Scene, CellGroup\n    pathable.py     # Pathable protocol -- point_at(t) interface\n    connection.py   # Connection -- reactive link between entities\n    point.py        # Point NamedTuple (x, y)\n    tangent.py      # Tangent angle utilities for pathables\n    stroked_path_mixin.py  # Shared cap/marker logic\n\n  entities/       # Concrete entity implementations\n    dot.py          # Dot (circle)\n    line.py         # Line (segment between two points)\n    curve.py        # Curve (quadratic Bezier)\n    ellipse.py      # Ellipse (with parametric support)\n    rect.py         # Rect (rectangle with rotation)\n    polygon.py      # Polygon (arbitrary vertices, preset shapes)\n    text.py         # Text (with textPath support)\n    path.py         # Path (renders any Pathable as smooth SVG)\n    entity_group.py # EntityGroup (composite entity)\n\n  scene/          # Top-level container\n    scene.py        # Scene -- owns grids, entities, rendering\n\n  grid/           # Spatial organization\n    grid.py         # Grid -- rows x cols of cells\n    cell.py         # Cell -- extends Surface, has image data\n    cell_group.py   # CellGroup -- multi-cell region\n\n  config/         # Configuration and extensibility\n    styles.py       # Style dataclasses (DotStyle, LineStyle, etc.)\n    caps.py         # Cap registry (arrow markers, custom caps)\n    palette.py      # Color palette utilities\n\n  image/          # Image loading and processing\n    image.py        # Image loader\n    layer.py        # Layer abstraction (color, brightness, alpha)\n    resize.py       # Image resizing utilities\n\n  color.py        # Color parsing and conversion\n  display.py      # Jupyter/notebook display helpers\n</code></pre>"},{"location":"developer-guide/01-architecture/#the-surface-protocol","title":"The Surface Protocol","text":"<p><code>Surface</code> is the base class that provides entity management and builder methods. Three classes extend it:</p> <pre><code>Surface (base)\n  |-- Scene       # Top-level SVG document, owns grids and connections\n  |-- Cell        # Single grid cell, has image data (color, brightness)\n  |-- CellGroup   # Rectangular selection of cells\n</code></pre>"},{"location":"developer-guide/01-architecture/#what-surface-provides","title":"What Surface provides","text":"<p>Every Surface has a rectangular region (<code>_x</code>, <code>_y</code>, <code>_width</code>, <code>_height</code>) and a list of entities (<code>_entities</code>). It provides:</p> Capability Methods Position resolution <code>relative_to_absolute()</code>, <code>absolute_to_relative()</code>, named positions (\"center\", \"top_left\", etc.) Builder methods <code>add_dot()</code>, <code>add_line()</code>, <code>add_curve()</code>, <code>add_ellipse()</code>, <code>add_polygon()</code>, <code>add_rect()</code>, <code>add_text()</code>, <code>add_path()</code>, <code>add_fill()</code>, <code>add_border()</code> Entity management <code>place()</code>, <code>add_entity()</code>, <code>remove()</code>, <code>clear()</code> Parametric positioning <code>_resolve_along()</code> -- resolves <code>along</code>/<code>t</code>/<code>align</code> params for any builder"},{"location":"developer-guide/01-architecture/#subclass-responsibilities","title":"Subclass responsibilities","text":"<p>Subclasses must initialize these attributes in <code>__init__</code>:</p> <pre><code>class Cell(Surface):\n    def __init__(self, ...):\n        self._x = ...       # top-left X\n        self._y = ...       # top-left Y\n        self._width = ...   # width in pixels\n        self._height = ...  # height in pixels\n        self._entities = [] # entity storage\n</code></pre> <p>Surface vs Entity</p> <p><code>Surface</code> and <code>Entity</code> are independent hierarchies. A Surface contains entities (composition). An Entity references its containing surface via <code>entity.cell</code>. The <code>EntityGroup</code> is the one entity that also contains other entities, but it does so through SVG <code>&lt;g&gt;</code> transforms, not through the Surface protocol.</p>"},{"location":"developer-guide/01-architecture/#entity-class-hierarchy","title":"Entity Class Hierarchy","text":"<p><code>Entity</code> is the abstract base for everything that can be drawn:</p> <pre><code>Entity (ABC)\n  |-- Dot              # Simple circle\n  |-- Line             # Segment, has StrokedPathMixin\n  |-- Curve            # Quadratic Bezier, has StrokedPathMixin\n  |-- Ellipse          # Oval with parametric support\n  |-- Rect             # Rectangle with rotation\n  |-- Polygon          # Arbitrary vertices\n  |-- Text             # Text with optional textPath\n  |-- Path             # Renders any Pathable, has StrokedPathMixin\n  |-- EntityGroup      # Composite entity (children in &lt;g&gt;)\n</code></pre>"},{"location":"developer-guide/01-architecture/#what-entity-provides","title":"What Entity provides","text":"<p>Every entity has:</p> <ul> <li>Position (<code>_position: Point</code>) -- the entity's reference point</li> <li>Z-index (<code>_z_index: int</code>) -- layer ordering for rendering</li> <li>Cell reference (<code>_cell: Surface | None</code>) -- back-reference to container</li> <li>Connections (<code>_connections: WeakSet</code>) -- tracked via weak references</li> <li>Movement -- <code>move_to()</code>, <code>move_by()</code>, <code>translate()</code></li> <li>Transforms -- <code>rotate()</code>, <code>scale()</code> (base implementations; entities override)</li> <li>Fitting -- <code>fit_within()</code>, <code>fit_to_cell()</code> -- scale to fit a target</li> <li>Connectivity -- <code>connect()</code>, <code>place_beside()</code></li> </ul>"},{"location":"developer-guide/01-architecture/#abstract-methods-every-entity-must-implement","title":"Abstract methods every entity must implement","text":"<pre><code>@property\n@abstractmethod\ndef anchor_names(self) -&gt; list[str]:\n    \"\"\"List available anchor names.\"\"\"\n\n@abstractmethod\ndef anchor(self, name: str) -&gt; Point:\n    \"\"\"Return anchor point by name.\"\"\"\n\n@abstractmethod\ndef to_svg(self) -&gt; str:\n    \"\"\"Render to SVG element string.\"\"\"\n\n@abstractmethod\ndef bounds(self) -&gt; tuple[float, float, float, float]:\n    \"\"\"Return (min_x, min_y, max_x, max_y).\"\"\"\n</code></pre>"},{"location":"developer-guide/01-architecture/#the-strokedpathmixin","title":"The StrokedPathMixin","text":"<p>Entities with stroked paths (Line, Curve, Path, Connection) share cap/marker logic through <code>StrokedPathMixin</code>:</p> <pre><code>class Line(StrokedPathMixin, Entity):\n    ...\n</code></pre> <p>The mixin provides:</p> <ul> <li><code>effective_start_cap</code> / <code>effective_end_cap</code> -- resolves per-end overrides</li> <li><code>get_required_markers()</code> -- returns SVG <code>&lt;marker&gt;</code> definitions needed for caps</li> <li><code>_svg_cap_and_marker_attrs()</code> -- computes <code>stroke-linecap</code> and <code>marker-start</code>/<code>marker-end</code> attributes</li> </ul>"},{"location":"developer-guide/01-architecture/#svg-rendering-pipeline","title":"SVG Rendering Pipeline","text":"<p>When you call <code>scene.to_svg()</code> or <code>scene.save(\"art.svg\")</code>, this pipeline executes:</p> <pre><code>scene.to_svg()\n    |\n    |-- 1. Write SVG header (&lt;svg xmlns=... width=... height=...&gt;)\n    |\n    |-- 2. Collect definitions (&lt;defs&gt;)\n    |   |-- _collect_markers()    # Arrow caps, custom marker caps\n    |   |-- _collect_path_defs()  # &lt;path&gt; elements for textPath\n    |\n    |-- 3. Render background (&lt;rect width=\"100%\" ...&gt;)\n    |\n    |-- 4. Collect all renderables\n    |   |-- Connections  -&gt; (z_index, svg_string)\n    |   |-- Entities     -&gt; (z_index, svg_string)\n    |   |   |-- scene._entities (direct entities)\n    |   |   |-- grid.all_entities() for each grid\n    |   |       |-- cell._entities for each cell\n    |\n    |-- 5. Sort by z_index (stable sort)\n    |\n    |-- 6. Render in sorted order\n    |\n    |-- 7. Close &lt;/svg&gt;\n</code></pre>"},{"location":"developer-guide/01-architecture/#step-by-step-detail","title":"Step-by-step detail","text":"<p>Step 2 -- Collecting definitions. The scene walks every entity and connection looking for marker-based caps (like <code>\"arrow\"</code>) and textPath path definitions. This is how entities can inject shared SVG <code>&lt;defs&gt;</code> without duplication:</p> <pre><code>def _collect_markers(self) -&gt; dict[str, str]:\n    markers: dict[str, str] = {}\n    for entity in self.entities:\n        if hasattr(entity, \"get_required_markers\"):\n            for mid, svg in entity.get_required_markers():\n                markers[mid] = svg  # dict deduplicates by ID\n    # ... also checks connections\n    return markers\n</code></pre> <p>Step 4 -- Collecting entities. The <code>scene.entities</code> property aggregates entities from all sources:</p> <pre><code>@property\ndef entities(self) -&gt; list[Entity]:\n    result = list(self._entities)        # Direct scene entities\n    for grid in self._grids:\n        result.extend(grid.all_entities())  # All cell entities\n    return result\n</code></pre> <p>Step 5 -- Z-index sorting. Python's <code>sort()</code> is stable, so entities with the same <code>z_index</code> preserve their insertion order:</p> <pre><code>renderables.sort(key=lambda x: x[0])  # Sort by z_index\n</code></pre> <p>Step 6 -- Rendering. Each entity's <code>to_svg()</code> is called exactly once. The returned string is indented and appended to the output:</p> <pre><code>for _, svg in renderables:\n    lines.append(f\"  {svg}\")\n</code></pre>"},{"location":"developer-guide/01-architecture/#marker-deduplication","title":"Marker deduplication","text":"<p>The cap system uses deterministic marker IDs based on cap name, color, and size. Two arrows with the same color and width share a single <code>&lt;marker&gt;</code> definition:</p> <pre><code># From config/caps.py\ndef make_marker_id(cap_name, color, size, *, for_start=False):\n    clean = color.lstrip(\"#\").lower()\n    size_str = f\"{size:.1f}\".replace(\".\", \"_\")\n    suffix = \"-start\" if for_start else \"\"\n    return f\"cap-{cap_name}-{clean}-{size_str}{suffix}\"\n</code></pre> <p>Extending the pipeline</p> <p>To add a new entity type that needs shared SVG definitions, implement <code>get_required_markers()</code> and/or <code>get_required_paths()</code> on your entity. The scene's rendering pipeline will automatically discover and deduplicate them.</p>"},{"location":"developer-guide/01-architecture/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"developer-guide/01-architecture/#composition-over-inheritance","title":"Composition over inheritance","text":"<p>Surfaces contain entities; entities reference their surface. There is no deep inheritance tree. The <code>StrokedPathMixin</code> adds cap behavior via mixin rather than a deeper class hierarchy.</p>"},{"location":"developer-guide/01-architecture/#weak-references-for-connections","title":"Weak references for connections","text":"<p>Entity connections use <code>WeakSet</code> so that deleting a connection does not require explicit cleanup on both entities:</p> <pre><code>self._connections: WeakSet[Connection] = WeakSet()\n</code></pre>"},{"location":"developer-guide/01-architecture/#relative-coordinate-system","title":"Relative coordinate system","text":"<p>Surface builder methods accept named positions (<code>\"center\"</code>, <code>\"top_left\"</code>) or relative tuples <code>(rx, ry)</code> where <code>(0, 0)</code> is top-left and <code>(1, 1)</code> is bottom-right. This keeps cell-level code resolution-independent.</p>"},{"location":"developer-guide/01-architecture/#entitycell-back-reference","title":"Entity.cell back-reference","text":"<p>Every entity knows which surface it lives in via <code>entity.cell</code>. This enables <code>fit_to_cell()</code> to work without passing the cell explicitly:</p> <pre><code>dot = cell.add_dot(radius=200)\ndot.fit_to_cell(0.85)  # Knows its cell, scales to fit\n</code></pre>"},{"location":"developer-guide/02-creating-entities/","title":"Creating Custom Entities","text":""},{"location":"developer-guide/02-creating-entities/#creating-custom-entities","title":"Creating Custom Entities","text":"<p>This guide walks through creating a custom entity by implementing the <code>Entity</code> abstract class. By the end, you will have built a fully functional <code>CrossHair</code> entity that integrates with the rendering pipeline, supports transforms, and works with <code>fit_to_cell()</code>.</p>"},{"location":"developer-guide/02-creating-entities/#the-entity-contract","title":"The Entity Contract","text":"<p>Every entity in PyFreeform extends the <code>Entity</code> ABC from <code>pyfreeform.core.entity</code>. The base class gives you positioning, movement, connections, and fitting for free. You provide the shape-specific logic.</p>"},{"location":"developer-guide/02-creating-entities/#required-abstract-methods","title":"Required abstract methods","text":"Method Purpose <code>anchor_names</code> (property) Return a <code>list[str]</code> of available anchor names <code>anchor(name)</code> Return a <code>Point</code> for the given anchor name <code>to_svg()</code> Return an SVG element string (e.g., <code>&lt;circle ... /&gt;</code>) <code>bounds()</code> Return <code>(min_x, min_y, max_x, max_y)</code> bounding box"},{"location":"developer-guide/02-creating-entities/#optional-methods-to-override","title":"Optional methods to override","text":"Method When to override <code>inner_bounds()</code> Non-rectangular shapes -- return the largest axis-aligned rectangle fully inside the entity. Default: same as <code>bounds()</code>. Used by <code>fit_within()</code>. <code>scale(factor, origin)</code> If your entity has geometry beyond its position (radius, endpoints, vertices). The base implementation only scales the position. <code>rotate(angle, origin)</code> If your entity has geometry that should rotate (endpoints, vertices, internal angles). The base implementation only rotates the position. <code>move_by(dx, dy)</code> If your entity stores absolute coordinates for sub-parts (e.g., Line stores <code>_end_offset</code>, Path stores Bezier segments). <code>get_required_markers()</code> If your entity needs SVG <code>&lt;marker&gt;</code> definitions in <code>&lt;defs&gt;</code>. Return <code>list[tuple[str, str]]</code> of <code>(marker_id, marker_svg)</code>. <code>get_required_paths()</code> If your entity needs SVG <code>&lt;path&gt;</code> definitions in <code>&lt;defs&gt;</code> (used by textPath). Return <code>list[tuple[str, str]]</code> of <code>(path_id, path_svg)</code>."},{"location":"developer-guide/02-creating-entities/#walkthrough-building-a-crosshair-entity","title":"Walkthrough: Building a CrossHair Entity","text":"<p>A crosshair is two perpendicular lines centered at a point, forming a <code>+</code> shape. It has a configurable size, color, and stroke width.</p>"},{"location":"developer-guide/02-creating-entities/#step-1-define-the-class","title":"Step 1: Define the class","text":"<pre><code>\"\"\"CrossHair - A crosshair marker entity.\"\"\"\n\nfrom __future__ import annotations\n\nimport math\n\nfrom pyfreeform.core.entity import Entity\nfrom pyfreeform.core.point import Point\nfrom pyfreeform.color import Color\n\n\nclass CrossHair(Entity):\n    \"\"\"\n    A crosshair (+) marker at a specific point.\n\n    Anchors:\n        - \"center\": The center point\n        - \"top\": Top of the vertical arm\n        - \"bottom\": Bottom of the vertical arm\n        - \"left\": Left end of the horizontal arm\n        - \"right\": Right end of the horizontal arm\n    \"\"\"\n\n    def __init__(\n        self,\n        x: float = 0,\n        y: float = 0,\n        size: float = 10,\n        color: str = \"black\",\n        width: float = 1,\n        z_index: int = 0,\n        opacity: float = 1.0,\n    ) -&gt; None:\n        super().__init__(x, y, z_index)  # (1)!\n        self.size = float(size)   # Half-length of each arm\n        self._color = Color(color)\n        self.width = float(width)\n        self.opacity = float(opacity)\n\n    @property\n    def color(self) -&gt; str:\n        return self._color.to_hex()\n\n    @color.setter\n    def color(self, value: str) -&gt; None:\n        self._color = Color(value)\n</code></pre> <ol> <li>Always call <code>super().__init__(x, y, z_index)</code>. This sets up <code>_position</code>, <code>_cell</code>, <code>_connections</code>, <code>_data</code>, and <code>_z_index</code>.</li> </ol> <p>Always call <code>super().__init__</code></p> <p>The base <code>Entity.__init__</code> initializes critical internal state: position, cell reference, connections WeakSet, and data dict. Forgetting this call will cause <code>AttributeError</code> at runtime.</p>"},{"location":"developer-guide/02-creating-entities/#step-2-implement-anchor_names-and-anchor","title":"Step 2: Implement anchor_names and anchor()","text":"<p>Anchors are named points on your entity that other entities can connect to or reference.</p> <pre><code>@property\ndef anchor_names(self) -&gt; list[str]:\n    return [\"center\", \"top\", \"bottom\", \"left\", \"right\"]\n\ndef anchor(self, name: str = \"center\") -&gt; Point:\n    if name == \"center\":\n        return self.position\n    elif name == \"top\":\n        return Point(self.x, self.y - self.size)\n    elif name == \"bottom\":\n        return Point(self.x, self.y + self.size)\n    elif name == \"left\":\n        return Point(self.x - self.size, self.y)\n    elif name == \"right\":\n        return Point(self.x + self.size, self.y)\n    raise ValueError(\n        f\"CrossHair has no anchor '{name}'. \"\n        f\"Available: {self.anchor_names}\"\n    )\n</code></pre> <p>Anchor naming conventions</p> <ul> <li>Always include <code>\"center\"</code> -- connections default to it.</li> <li>Use compass-style names for directional anchors: <code>\"top\"</code>, <code>\"bottom\"</code>, <code>\"left\"</code>, <code>\"right\"</code>.</li> <li>For path-like entities, use <code>\"start\"</code>, <code>\"center\"</code>, <code>\"end\"</code>.</li> </ul>"},{"location":"developer-guide/02-creating-entities/#step-3-implement-bounds","title":"Step 3: Implement bounds()","text":"<p>Return the axis-aligned bounding box as <code>(min_x, min_y, max_x, max_y)</code>. This is used by <code>fit_to_cell()</code>, <code>fit_within()</code>, and <code>place_beside()</code>.</p> <pre><code>def bounds(self) -&gt; tuple[float, float, float, float]:\n    return (\n        self.x - self.size,\n        self.y - self.size,\n        self.x + self.size,\n        self.y + self.size,\n    )\n</code></pre> <p>For the crosshair, <code>inner_bounds()</code> would be trivially small (the intersection point), so we leave the default which returns the same as <code>bounds()</code>.</p>"},{"location":"developer-guide/02-creating-entities/#step-4-implement-to_svg","title":"Step 4: Implement to_svg()","text":"<p>This is where your entity becomes visible. Return a valid SVG element string.</p> <pre><code>def to_svg(self) -&gt; str:\n    # Horizontal arm\n    h = (\n        f'&lt;line x1=\"{self.x - self.size}\" y1=\"{self.y}\" '\n        f'x2=\"{self.x + self.size}\" y2=\"{self.y}\" '\n        f'stroke=\"{self.color}\" stroke-width=\"{self.width}\" '\n        f'stroke-linecap=\"round\"'\n    )\n    # Vertical arm\n    v = (\n        f'&lt;line x1=\"{self.x}\" y1=\"{self.y - self.size}\" '\n        f'x2=\"{self.x}\" y2=\"{self.y + self.size}\" '\n        f'stroke=\"{self.color}\" stroke-width=\"{self.width}\" '\n        f'stroke-linecap=\"round\"'\n    )\n\n    # Wrap in a group\n    parts = [f'&lt;g']\n    if self.opacity &lt; 1.0:\n        parts.append(f' opacity=\"{self.opacity}\"')\n    parts.append(f'&gt;{h} /&gt;{v} /&gt;&lt;/g&gt;')\n    return ''.join(parts)\n</code></pre> <p>SVG output rules</p> <ul> <li>Return a single SVG element. Use <code>&lt;g&gt;</code> to group multiple sub-elements.</li> <li>Only emit optional attributes (like <code>opacity</code>) when they differ from defaults.</li> <li>The scene indents your output with <code>f\"  {svg}\"</code>, so do not add leading whitespace.</li> </ul>"},{"location":"developer-guide/02-creating-entities/#step-5-implement-scale-and-rotate","title":"Step 5: Implement scale() and rotate()","text":"<p>The base <code>Entity.scale()</code> and <code>Entity.rotate()</code> only move the position relative to an origin. If your entity has internal geometry (like <code>size</code>), you must override these methods.</p> <pre><code>def scale(\n    self,\n    factor: float,\n    origin: Point | tuple[float, float] | None = None,\n) -&gt; CrossHair:\n    # Scale the internal geometry\n    self.size *= factor\n    self.width *= factor\n\n    # Also scale position relative to origin (if given)\n    if origin is not None:\n        super().scale(factor, origin)\n\n    return self\n\ndef rotate(\n    self,\n    angle: float,\n    origin: Point | tuple[float, float] | None = None,\n) -&gt; CrossHair:\n    # For a crosshair, rotation doesn't change the + shape\n    # (it's symmetric), but we still rotate the position.\n    if origin is not None:\n        super().rotate(angle, origin)\n    return self\n</code></pre> <p>The scale/rotate pattern</p> <ol> <li>Scale internal geometry (radius, size, endpoints, vertices).</li> <li>Call <code>super().scale(factor, origin)</code> to handle position scaling.</li> <li>Return <code>self</code> for method chaining.</li> </ol> <p>For entities with rotation-sensitive geometry (like Line, Polygon), override <code>rotate()</code> to transform all internal points. See <code>Line.rotate()</code> for a full example.</p>"},{"location":"developer-guide/02-creating-entities/#complete-crosshair-entity","title":"Complete CrossHair Entity","text":"<p>Here is the full implementation:</p> <pre><code>\"\"\"CrossHair - A crosshair marker entity.\"\"\"\n\nfrom __future__ import annotations\n\nfrom pyfreeform.core.entity import Entity\nfrom pyfreeform.core.point import Point\nfrom pyfreeform.color import Color\n\n\nclass CrossHair(Entity):\n    \"\"\"A crosshair (+) marker at a specific point.\"\"\"\n\n    def __init__(\n        self,\n        x: float = 0,\n        y: float = 0,\n        size: float = 10,\n        color: str = \"black\",\n        width: float = 1,\n        z_index: int = 0,\n        opacity: float = 1.0,\n    ) -&gt; None:\n        super().__init__(x, y, z_index)\n        self.size = float(size)\n        self._color = Color(color)\n        self.width = float(width)\n        self.opacity = float(opacity)\n\n    @property\n    def color(self) -&gt; str:\n        return self._color.to_hex()\n\n    @color.setter\n    def color(self, value: str) -&gt; None:\n        self._color = Color(value)\n\n    @property\n    def anchor_names(self) -&gt; list[str]:\n        return [\"center\", \"top\", \"bottom\", \"left\", \"right\"]\n\n    def anchor(self, name: str = \"center\") -&gt; Point:\n        if name == \"center\":\n            return self.position\n        elif name == \"top\":\n            return Point(self.x, self.y - self.size)\n        elif name == \"bottom\":\n            return Point(self.x, self.y + self.size)\n        elif name == \"left\":\n            return Point(self.x - self.size, self.y)\n        elif name == \"right\":\n            return Point(self.x + self.size, self.y)\n        raise ValueError(\n            f\"CrossHair has no anchor '{name}'. \"\n            f\"Available: {self.anchor_names}\"\n        )\n\n    def bounds(self) -&gt; tuple[float, float, float, float]:\n        return (\n            self.x - self.size,\n            self.y - self.size,\n            self.x + self.size,\n            self.y + self.size,\n        )\n\n    def scale(\n        self,\n        factor: float,\n        origin: Point | tuple[float, float] | None = None,\n    ) -&gt; CrossHair:\n        self.size *= factor\n        self.width *= factor\n        if origin is not None:\n            super().scale(factor, origin)\n        return self\n\n    def rotate(\n        self,\n        angle: float,\n        origin: Point | tuple[float, float] | None = None,\n    ) -&gt; CrossHair:\n        if origin is not None:\n            super().rotate(angle, origin)\n        return self\n\n    def to_svg(self) -&gt; str:\n        h = (\n            f'&lt;line x1=\"{self.x - self.size}\" y1=\"{self.y}\" '\n            f'x2=\"{self.x + self.size}\" y2=\"{self.y}\" '\n            f'stroke=\"{self.color}\" stroke-width=\"{self.width}\" '\n            f'stroke-linecap=\"round\" /&gt;'\n        )\n        v = (\n            f'&lt;line x1=\"{self.x}\" y1=\"{self.y - self.size}\" '\n            f'x2=\"{self.x}\" y2=\"{self.y + self.size}\" '\n            f'stroke=\"{self.color}\" stroke-width=\"{self.width}\" '\n            f'stroke-linecap=\"round\" /&gt;'\n        )\n        parts = ['&lt;g']\n        if self.opacity &lt; 1.0:\n            parts.append(f' opacity=\"{self.opacity}\"')\n        parts.append(f'&gt;{h}{v}&lt;/g&gt;')\n        return ''.join(parts)\n\n    def __repr__(self) -&gt; str:\n        return f\"CrossHair({self.x}, {self.y}, size={self.size})\"\n</code></pre>"},{"location":"developer-guide/02-creating-entities/#using-your-custom-entity","title":"Using Your Custom Entity","text":"<p>Custom entities work with all placement and fitting APIs:</p> <pre><code>from pyfreeform import Scene\n\nscene = Scene.with_grid(cols=10, rows=10, cell_size=30)\n\nfor cell in scene.grid:\n    ch = CrossHair(size=20, color=\"coral\", width=1.5)\n    cell.place(ch)               # Centers in cell\n    ch.fit_to_cell(0.8)          # Scales to 80% of cell\n\nscene.save(\"crosshairs.svg\")\n</code></pre> <p>Connections work too:</p> <pre><code>ch1 = CrossHair(100, 100, size=15, color=\"navy\")\nch2 = CrossHair(200, 150, size=15, color=\"navy\")\nscene.add(ch1, ch2)\n\n# Connect right anchor of ch1 to left anchor of ch2\nch1.connect(ch2, start_anchor=\"right\", end_anchor=\"left\",\n            style={\"color\": \"gray\", \"width\": 1})\n</code></pre>"},{"location":"developer-guide/02-creating-entities/#adding-svg-definitions","title":"Adding SVG Definitions","text":"<p>If your entity needs SVG <code>&lt;marker&gt;</code> or <code>&lt;path&gt;</code> definitions in <code>&lt;defs&gt;</code>, implement the optional methods:</p> <pre><code>def get_required_markers(self) -&gt; list[tuple[str, str]]:\n    \"\"\"Return (marker_id, marker_svg) tuples.\"\"\"\n    marker_id = f\"crosshair-dot-{self.color.lstrip('#')}\"\n    marker_svg = (\n        f'&lt;marker id=\"{marker_id}\" viewBox=\"0 0 4 4\" '\n        f'refX=\"2\" refY=\"2\" markerWidth=\"4\" markerHeight=\"4\"&gt;'\n        f'&lt;circle cx=\"2\" cy=\"2\" r=\"2\" fill=\"{self.color}\" /&gt;'\n        f'&lt;/marker&gt;'\n    )\n    return [(marker_id, marker_svg)]\n</code></pre> <p>The scene rendering pipeline automatically discovers and deduplicates these definitions.</p>"},{"location":"developer-guide/02-creating-entities/#checklist-for-new-entities","title":"Checklist for New Entities","text":"<p>Before considering your entity complete, verify:</p> <ul> <li>[ ] <code>super().__init__(x, y, z_index)</code> is called in <code>__init__</code></li> <li>[ ] <code>anchor_names</code> includes <code>\"center\"</code></li> <li>[ ] <code>anchor()</code> raises <code>ValueError</code> for unknown names</li> <li>[ ] <code>bounds()</code> returns <code>(min_x, min_y, max_x, max_y)</code></li> <li>[ ] <code>to_svg()</code> returns a single SVG element (use <code>&lt;g&gt;</code> for multiple)</li> <li>[ ] <code>scale()</code> scales internal geometry and calls <code>super().scale()</code></li> <li>[ ] <code>rotate()</code> handles internal geometry if shape is asymmetric</li> <li>[ ] Opacity attributes are only emitted when not equal to 1.0</li> <li>[ ] <code>__repr__</code> is implemented for debugging</li> <li>[ ] Works with <code>cell.place()</code> and <code>fit_to_cell()</code></li> </ul>"},{"location":"developer-guide/03-pathable-protocol/","title":"The Pathable Protocol","text":""},{"location":"developer-guide/03-pathable-protocol/#the-pathable-protocol","title":"The Pathable Protocol","text":"<p>The <code>Pathable</code> protocol is the foundation of parametric positioning in PyFreeform. Any object that implements <code>point_at(t)</code> can be used with the <code>along</code>/<code>t</code> system to position entities along arbitrary paths.</p> <p>This guide covers the protocol, its optional methods, how the rendering pipeline converts pathables to smooth SVG, and a complete walkthrough of building a custom Lissajous curve pathable.</p>"},{"location":"developer-guide/03-pathable-protocol/#the-protocol-definition","title":"The Protocol Definition","text":"<pre><code>from typing import Protocol, runtime_checkable\nfrom pyfreeform.core.point import Point\n\n@runtime_checkable\nclass Pathable(Protocol):\n    def point_at(self, t: float) -&gt; Point:\n        \"\"\"Get a point at parameter t (0.0 to 1.0).\"\"\"\n        ...\n</code></pre> <p>That is the entire required interface -- a single method. The protocol is <code>@runtime_checkable</code>, meaning <code>isinstance(obj, Pathable)</code> works at runtime.</p>"},{"location":"developer-guide/03-pathable-protocol/#how-t-is-interpreted","title":"How <code>t</code> is interpreted","text":"<code>t</code> value Meaning <code>0.0</code> Start of the path <code>0.5</code> Midpoint of the path <code>1.0</code> End of the path <p>For closed paths (like ellipses), <code>t=0.0</code> and <code>t=1.0</code> return the same point. For open paths (like lines), they return opposite endpoints.</p>"},{"location":"developer-guide/03-pathable-protocol/#built-in-pathable-types","title":"Built-in pathable types","text":"<p>These entity types implement <code>point_at(t)</code> out of the box:</p> Type Path shape Closed? <code>Line</code> Straight segment No <code>Curve</code> Quadratic Bezier No <code>Ellipse</code> Elliptical arc Yes <code>Path</code> Any Pathable rendered as Bezier Configurable <code>Connection</code> Straight segment between entities No"},{"location":"developer-guide/03-pathable-protocol/#optional-methods","title":"Optional Methods","text":"<p>Beyond <code>point_at(t)</code>, pathables can implement additional methods that unlock more features:</p>"},{"location":"developer-guide/03-pathable-protocol/#arc_length-float","title":"<code>arc_length() -&gt; float</code>","text":"<p>Returns the approximate total length of the path in pixels. Used by <code>add_text()</code> for auto-sizing font in textPath mode.</p> <pre><code>def arc_length(self) -&gt; float:\n    \"\"\"Approximate total arc length in pixels.\"\"\"\n    total = 0.0\n    prev = self.point_at(0.0)\n    for i in range(1, 101):\n        curr = self.point_at(i / 100)\n        total += prev.distance_to(curr)\n        prev = curr\n    return total\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#angle_att-float","title":"<code>angle_at(t) -&gt; float</code>","text":"<p>Returns the tangent angle in degrees at parameter <code>t</code>. Used by the <code>align=True</code> feature to rotate entities to follow the path direction. If not implemented, the system falls back to numeric differentiation via <code>tangent.get_angle_at()</code>.</p> <pre><code>def angle_at(self, t: float) -&gt; float:\n    \"\"\"Tangent angle in degrees at parameter t.\"\"\"\n    ...\n</code></pre> <p>Numeric fallback</p> <p>When <code>angle_at()</code> is not implemented, PyFreeform uses <code>get_angle_at()</code> from <code>core/tangent.py</code>, which computes the angle via finite differences on <code>point_at()</code>. This works well for smooth paths. Only implement <code>angle_at()</code> when you have an exact analytical formula or when the numeric fallback is insufficiently accurate.</p>"},{"location":"developer-guide/03-pathable-protocol/#to_svg_path_d-str","title":"<code>to_svg_path_d() -&gt; str</code>","text":"<p>Returns the SVG <code>d</code> attribute string for the path. Required for textPath warping (text that follows a curve). Without this method, <code>add_text(along=path)</code> will raise a <code>TypeError</code>.</p> <pre><code>def to_svg_path_d(self) -&gt; str:\n    \"\"\"SVG path d attribute string.\"\"\"\n    return f\"M {self.start.x} {self.start.y} L {self.end.x} {self.end.y}\"\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#how-the-alongt-system-works","title":"How the along/t System Works","text":"<p>When you write <code>cell.add_dot(along=curve, t=0.5)</code>, here is what happens internally:</p> <pre><code>cell.add_dot(along=curve, t=0.5)\n    |\n    |-- Surface._resolve_along(along, t, align=False, user_rotation=0)\n    |   |-- position = along.point_at(0.5)     # Get position from pathable\n    |   |-- return (position, 0)                # No rotation (align=False)\n    |\n    |-- Dot(position.x, position.y, ...)        # Create entity at that position\n    |-- self._register_entity(dot)              # Register with surface\n</code></pre> <p>With <code>align=True</code>, the rotation step becomes:</p> <pre><code>Surface._resolve_along(along, t=0.5, align=True, user_rotation=0)\n    |\n    |-- position = along.point_at(0.5)\n    |-- tangent_angle = get_angle_at(along, 0.5)  # From tangent.py\n    |   |-- If along has angle_at(): use it directly\n    |   |-- Otherwise: numeric diff via point_at(0.5 - eps) and point_at(0.5 + eps)\n    |-- return (position, tangent_angle + user_rotation)\n</code></pre> <p>This works identically for <code>add_line()</code>, <code>add_curve()</code>, <code>add_ellipse()</code>, <code>add_polygon()</code>, <code>add_rect()</code>, and <code>add_text()</code> -- every builder method supports <code>along</code>/<code>t</code>/<code>align</code>.</p>"},{"location":"developer-guide/03-pathable-protocol/#walkthrough-creating-a-lissajous-curve-pathable","title":"Walkthrough: Creating a Lissajous Curve Pathable","text":"<p>A Lissajous curve traces a parametric path defined by:</p> <pre><code>x(t) = A * sin(a*t + delta)\ny(t) = B * sin(b*t)\n</code></pre> <p>where <code>a</code> and <code>b</code> control frequency, <code>delta</code> is the phase shift, and <code>A</code>/<code>B</code> control amplitude.</p>"},{"location":"developer-guide/03-pathable-protocol/#step-1-implement-point_att","title":"Step 1: Implement point_at(t)","text":"<pre><code>import math\nfrom pyfreeform.core.point import Point\n\n\nclass Lissajous:\n    \"\"\"A Lissajous curve pathable.\"\"\"\n\n    def __init__(\n        self,\n        center: Point | tuple[float, float] = (0, 0),\n        a: int = 3,\n        b: int = 2,\n        delta: float = math.pi / 2,\n        size: float = 50,\n    ) -&gt; None:\n        if isinstance(center, tuple):\n            center = Point(*center)\n        self.center = center\n        self.a = a            # Horizontal frequency\n        self.b = b            # Vertical frequency\n        self.delta = delta    # Phase shift\n        self.size = size      # Amplitude (pixels)\n\n    def point_at(self, t: float) -&gt; Point:  # (1)!\n        \"\"\"Get point at parameter t (0.0 to 1.0).\"\"\"\n        angle = t * 2 * math.pi\n        x = self.center.x + self.size * math.sin(self.a * angle + self.delta)\n        y = self.center.y + self.size * math.sin(self.b * angle)\n        return Point(x, y)\n</code></pre> <ol> <li>This single method is all that is required. The class now works with <code>add_dot(along=lissajous, t=0.5)</code>.</li> </ol> <p>This is already a fully functional pathable. You can use it immediately:</p> <pre><code>scene = Scene.with_grid(cols=20, rows=20, cell_size=15)\nliss = Lissajous(center=scene.grid[10][10].center, a=3, b=2, size=80)\n\nfor cell in scene.grid:\n    cell.add_dot(along=liss, t=cell.brightness, color=\"coral\", radius=2)\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#step-2-add-angle_at-for-alignment","title":"Step 2: Add angle_at() for alignment","text":"<p>For entities to rotate and follow the curve direction, implement <code>angle_at()</code>:</p> <pre><code>def angle_at(self, t: float) -&gt; float:\n    \"\"\"Tangent angle in degrees at parameter t.\"\"\"\n    angle = t * 2 * math.pi\n    # Derivatives of the parametric equations\n    dx = self.size * self.a * math.cos(self.a * angle + self.delta) * 2 * math.pi\n    dy = self.size * self.b * math.cos(self.b * angle) * 2 * math.pi\n    if dx == 0 and dy == 0:\n        return 0.0\n    return math.degrees(math.atan2(dy, dx))\n</code></pre> <p>Now <code>align=True</code> uses the exact tangent rather than numeric approximation:</p> <pre><code>curve_path = cell.add_curve()\n# Small rectangles aligned to the Lissajous tangent\ncell.add_rect(width=8, height=3, along=liss, t=0.25, align=True)\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#step-3-add-arc_length-for-text-sizing","title":"Step 3: Add arc_length() for text sizing","text":"<pre><code>def arc_length(self, samples: int = 200) -&gt; float:\n    \"\"\"Approximate arc length via polyline sampling.\"\"\"\n    total = 0.0\n    prev = self.point_at(0.0)\n    for i in range(1, samples + 1):\n        curr = self.point_at(i / samples)\n        dx = curr.x - prev.x\n        dy = curr.y - prev.y\n        total += math.sqrt(dx * dx + dy * dy)\n        prev = curr\n    return total\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#step-4-add-to_svg_path_d-for-textpath-support","title":"Step 4: Add to_svg_path_d() for textPath support","text":"<p>For text to warp along the Lissajous curve, it needs an SVG path definition. The simplest approach is to sample points and emit line segments:</p> <pre><code>def to_svg_path_d(self, samples: int = 200) -&gt; str:\n    \"\"\"SVG path d attribute as a polyline approximation.\"\"\"\n    p0 = self.point_at(0.0)\n    parts = [f\"M {p0.x} {p0.y}\"]\n    for i in range(1, samples + 1):\n        p = self.point_at(i / samples)\n        parts.append(f\" L {p.x} {p.y}\")\n    return \"\".join(parts)\n</code></pre> <p>Polyline vs Bezier</p> <p>A polyline <code>to_svg_path_d()</code> works but produces large SVG. For a smoother and smaller result, use <code>add_path()</code> instead, which fits cubic Beziers via Hermite interpolation. The <code>to_svg_path_d()</code> method is mainly needed for <code>textPath</code> support.</p>"},{"location":"developer-guide/03-pathable-protocol/#how-add_path-converts-pathables-to-smooth-svg","title":"How add_path() Converts Pathables to Smooth SVG","text":"<p>When you call <code>cell.add_path(lissajous)</code>, the <code>Path</code> entity converts your pathable into smooth cubic Bezier curves. Here is the algorithm:</p>"},{"location":"developer-guide/03-pathable-protocol/#hermite-to-bezier-interpolation","title":"Hermite-to-Bezier interpolation","text":"<pre><code>For each segment i from 0 to N-1:\n    1. Sample the pathable at t_i and t_{i+1}\n    2. Compute tangent vectors at both points (via numeric differentiation)\n    3. Convert Hermite form to Bezier control points:\n       cp1 = p0 + tangent_0 * dt/3\n       cp2 = p3 - tangent_1 * dt/3\n    4. Clamp control points to prevent blowup (max 75% of chord length)\n</code></pre> <p>The result is C1-continuous -- tangent directions match at every joint, giving a visually smooth curve with no kinks.</p>"},{"location":"developer-guide/03-pathable-protocol/#for-closed-paths","title":"For closed paths","text":"<p>Closed paths wrap the last segment back to the first point. The tangent computation uses modular arithmetic (<code>t % 1.0</code>) so the seam is invisible:</p> <pre><code># From path.py\nif closed and start_t == 0.0 and end_t == 1.0:\n    t_values = [i / n for i in range(n)]  # N points, no duplicate endpoint\n    # Last segment: points[N-1] -&gt; points[0], with wrapping tangents\n    for i in range(n):\n        j = (i + 1) % n  # Wraps back to 0\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#sub-paths-arcs","title":"Sub-paths (arcs)","text":"<p>Use <code>start_t</code> and <code>end_t</code> to render only a portion of any pathable:</p> <pre><code># Render just the first quarter of a Lissajous curve\ncell.add_path(liss, start_t=0.0, end_t=0.25, color=\"red\", width=2)\n\n# Render an arc of an ellipse\nellipse = cell.add_ellipse(rx=30, ry=20)\ncell.add_path(ellipse, start_t=0.0, end_t=0.5, color=\"blue\")\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#complete-lissajous-pathable","title":"Complete Lissajous Pathable","text":"<pre><code>\"\"\"Lissajous - A Lissajous curve pathable.\"\"\"\n\nimport math\nfrom pyfreeform.core.point import Point\n\n\nclass Lissajous:\n    \"\"\"\n    A Lissajous curve: x = A*sin(a*t + delta), y = B*sin(b*t).\n\n    This is a closed curve when a/b is rational. Common ratios:\n        a=3, b=2 -&gt; figure-eight variant\n        a=1, b=2 -&gt; parabola-like\n        a=5, b=4 -&gt; complex knot\n    \"\"\"\n\n    def __init__(\n        self,\n        center: Point | tuple[float, float] = (0, 0),\n        a: int = 3,\n        b: int = 2,\n        delta: float = math.pi / 2,\n        size: float = 50,\n    ) -&gt; None:\n        if isinstance(center, tuple):\n            center = Point(*center)\n        self.center = center\n        self.a = a\n        self.b = b\n        self.delta = delta\n        self.size = size\n\n    def point_at(self, t: float) -&gt; Point:\n        angle = t * 2 * math.pi\n        x = self.center.x + self.size * math.sin(self.a * angle + self.delta)\n        y = self.center.y + self.size * math.sin(self.b * angle)\n        return Point(x, y)\n\n    def angle_at(self, t: float) -&gt; float:\n        angle = t * 2 * math.pi\n        dx = self.size * self.a * math.cos(self.a * angle + self.delta) * 2 * math.pi\n        dy = self.size * self.b * math.cos(self.b * angle) * 2 * math.pi\n        if dx == 0 and dy == 0:\n            return 0.0\n        return math.degrees(math.atan2(dy, dx))\n\n    def arc_length(self, samples: int = 200) -&gt; float:\n        total = 0.0\n        prev = self.point_at(0.0)\n        for i in range(1, samples + 1):\n            curr = self.point_at(i / samples)\n            dx = curr.x - prev.x\n            dy = curr.y - prev.y\n            total += math.sqrt(dx * dx + dy * dy)\n            prev = curr\n        return total\n\n    def to_svg_path_d(self, samples: int = 200) -&gt; str:\n        p0 = self.point_at(0.0)\n        parts = [f\"M {p0.x} {p0.y}\"]\n        for i in range(1, samples + 1):\n            p = self.point_at(i / samples)\n            parts.append(f\" L {p.x} {p.y}\")\n        return \"\".join(parts)\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#using-it-in-practice","title":"Using It in Practice","text":""},{"location":"developer-guide/03-pathable-protocol/#position-dots-along-a-lissajous-curve","title":"Position dots along a Lissajous curve","text":"<pre><code>from pyfreeform import Scene, Point\n\nscene = Scene(400, 400, background=\"#1a1a2e\")\nliss = Lissajous(center=Point(200, 200), a=3, b=2, size=150)\n\n# Render the curve itself\nscene.add_path(liss, closed=True, color=\"#334155\", width=1)\n\n# Place 50 dots along it\nfor i in range(50):\n    t = i / 50\n    scene.add_dot(along=liss, t=t, color=\"coral\", radius=3)\n\nscene.save(\"lissajous.svg\")\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#render-as-a-filled-closed-path","title":"Render as a filled closed path","text":"<pre><code>scene.add_path(\n    liss,\n    closed=True,\n    color=\"navy\",\n    fill=\"lightblue\",\n    width=1.5,\n    opacity=0.8,\n)\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#warp-text-along-a-lissajous-curve","title":"Warp text along a Lissajous curve","text":"<pre><code>scene.add_text(\n    \"Hello Lissajous! \",\n    along=liss,\n    color=\"white\",\n    font_size=14,\n)\n</code></pre>"},{"location":"developer-guide/03-pathable-protocol/#protocol-summary","title":"Protocol Summary","text":"Method Required? Enables <code>point_at(t) -&gt; Point</code> Yes <code>along=</code>/<code>t=</code> positioning for all builder methods <code>angle_at(t) -&gt; float</code> No Exact tangent for <code>align=True</code> (fallback: numeric diff) <code>arc_length() -&gt; float</code> No Auto font sizing for textPath mode <code>to_svg_path_d() -&gt; str</code> No textPath warping (<code>add_text(along=...)</code> without <code>t</code>) <p>The minimum viable pathable is a class with a single <code>point_at(t)</code> method. Everything else is optional and adds capabilities incrementally.</p>"},{"location":"gallery/","title":"Gallery","text":""},{"location":"gallery/#gallery","title":"Gallery","text":"<p>A showcase of the best artwork generated across the wiki. Click any image to zoom in. Each links to the page where it's explained.</p>"},{"location":"gallery/#image-to-art","title":"Image-to-Art","text":"[Classic Dot Art](../recipes/01-image-to-art.md) [Halftone Effect](../recipes/01-image-to-art.md) [Shape Art](../recipes/01-image-to-art.md)"},{"location":"gallery/#geometric-patterns","title":"Geometric Patterns","text":"[Rotating Hexagonal Tiling](../recipes/02-geometric-patterns.md) [Sine Wave Pattern](../recipes/02-geometric-patterns.md) [Concentric Rings](../recipes/02-geometric-patterns.md)"},{"location":"gallery/#flowing-art","title":"Flowing Art","text":"[Wave Visualization](../recipes/03-flowing-curves.md) [Spiral Paths](../recipes/03-flowing-curves.md) [Image Curves](../recipes/03-flowing-curves.md)"},{"location":"gallery/#networks-typography","title":"Networks &amp; Typography","text":"[Brightness Network](../recipes/04-connected-networks.md) [ASCII Art](../recipes/05-typographic-art.md) [Full Stack Composition](../recipes/06-advanced-compositions.md)"},{"location":"gallery/#guide-highlights","title":"Guide Highlights","text":"[Shapes by Brightness](../guide/03-drawing-with-entities.md) [EntityGroup Flowers](../guide/06-shapes-and-polygons.md) [Edge Detection](../guide/02-working-with-cells.md)"},{"location":"gallery/#home-page-art","title":"Home Page Art","text":"[Hero Artwork](../index.md) [Hexagons](../index.md) [Star Field](../index.md)"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#getting-started","title":"Getting Started","text":"<p>New to PyFreeform? Start here. In three short pages you'll go from installation to creating beautiful generative art.</p> <ul> <li> <p>Installation</p> <p>Install PyFreeform and verify everything works with a quick test.</p> <p>:octicons-arrow-right-24: Install now</p> </li> <li> <p>Your First Artwork</p> <p>Create art from an image or from scratch \u2014 two paths, one powerful library.</p> <p>:octicons-arrow-right-24: Start creating</p> </li> <li> <p>How PyFreeform Works</p> <p>Understand the Scene \u2192 Grid \u2192 Cell \u2192 Entity mental model.</p> <p>:octicons-arrow-right-24: Learn the concepts</p> </li> </ul>"},{"location":"getting-started/01-installation/","title":"Installation","text":""},{"location":"getting-started/01-installation/#installation","title":"Installation","text":""},{"location":"getting-started/01-installation/#install-pyfreeform","title":"Install PyFreeform","text":"<pre><code>pip install pyfreeform\n</code></pre> <p>Requirements: Python 3.10+ and Pillow (installed automatically).</p>"},{"location":"getting-started/01-installation/#verify-it-works","title":"Verify It Works","text":"<p>Create a file called <code>hello.py</code>:</p> <pre><code>from pyfreeform import Scene, Palette\n\ncolors = Palette.midnight()\nscene = Scene.with_grid(cols=8, rows=8, cell_size=30, background=colors.background)\n\nfor cell in scene.grid:\n    nx, ny = cell.normalized_position\n    radius = (nx + ny) / 2 * 12\n    cell.add_dot(radius=radius, color=colors.primary)\n\nscene.save(\"hello.svg\")\nprint(\"Saved hello.svg\")\n</code></pre> <p>Run it:</p> <pre><code>python hello.py\n</code></pre> <p>Open <code>hello.svg</code> in your browser. You should see a grid of dots that grow from top-left to bottom-right.</p> <p>Ready to go</p> <p>If you see dots, everything is working. Head to Your First Artwork to create something more exciting.</p>"},{"location":"getting-started/01-installation/#optional-jupyter-support","title":"Optional: Jupyter Support","text":"<p>PyFreeform works in Jupyter notebooks with inline SVG display:</p> <pre><code>from pyfreeform import Scene, display\n\nscene = Scene.with_grid(cols=10, rows=10, cell_size=20)\nfor cell in scene.grid:\n    cell.add_dot(color=\"coral\")\ndisplay(scene)  # Renders inline in the notebook\n</code></pre>"},{"location":"getting-started/01-installation/#troubleshooting","title":"Troubleshooting","text":"ImportError: No module named 'pyfreeform' <p>Make sure you're using the same Python environment where you installed the package: </p><pre><code>python -m pip install pyfreeform\n</code></pre><p></p> Pillow not found <p>Pillow should install automatically. If not: </p><pre><code>pip install Pillow\n</code></pre><p></p>"},{"location":"getting-started/02-your-first-artwork/","title":"Your First Artwork","text":""},{"location":"getting-started/02-your-first-artwork/#your-first-artwork","title":"Your First Artwork","text":"<p>PyFreeform gives you two ways to create art: from an image or from scratch. Both use the same powerful grid system.</p> From an ImageFrom Scratch"},{"location":"getting-started/02-your-first-artwork/#load-an-image","title":"Load an Image","text":"<p><code>Scene.from_image()</code> divides a photo into a grid of cells. Each cell knows the color and brightness of the pixels beneath it.</p> <pre><code>from pyfreeform import Scene\n\nscene = Scene.from_image(\"MonaLisa.jpg\", grid_size=35, cell_size=12)\n\nfor cell in scene.grid:\n    cell.add_dot(radius=3, color=cell.color)  # (1)!\n\nscene.save(\"artwork.svg\")\n</code></pre> <ol> <li><code>cell.color</code> is the hex color sampled from the image at this cell's position.</li> </ol> <p></p> Every cell gets a dot colored by the image \u2014 already recognizable! <p></p>"},{"location":"getting-started/02-your-first-artwork/#size-by-brightness","title":"Size by Brightness","text":"<p>Make bright areas pop and dark areas recede by tying dot radius to brightness:</p> <pre><code>for cell in scene.grid:\n    radius = cell.brightness * 5  # (1)!\n    if radius &gt; 0.3:\n        cell.add_dot(radius=radius, color=cell.color)\n</code></pre> <ol> <li><code>cell.brightness</code> is a float from 0.0 (black) to 1.0 (white).</li> </ol> <p></p> Larger dots in bright areas create depth and dimension. <p></p>"},{"location":"getting-started/02-your-first-artwork/#polish-it","title":"Polish It","text":"<p>Add a subtle border and vary opacity for a finished look:</p> <pre><code>scene = Scene.from_image(\"MonaLisa.jpg\", grid_size=40, cell_size=11)\n\nfor cell in scene.grid:\n    radius = cell.brightness * 5\n    if radius &gt; 0.3:\n        cell.add_dot(\n            radius=radius,\n            color=cell.color,\n            opacity=0.6 + cell.brightness * 0.4,\n        )\n\nfor cell in scene.grid.border():  # (1)!\n    cell.add_border(color=\"#333344\", width=0.3)\n\nscene.save(\"artwork.svg\")\n</code></pre> <ol> <li><code>grid.border()</code> selects only the cells on the grid's outer edge.</li> </ol> <p></p> Opacity variation and a border frame give it a gallery-ready feel. <p></p>"},{"location":"getting-started/02-your-first-artwork/#start-with-a-grid","title":"Start with a Grid","text":"<p><code>Scene.with_grid()</code> creates an empty grid \u2014 no image needed. Use position and math to drive the visuals.</p> <pre><code>from pyfreeform import Scene, Palette\n\ncolors = Palette.sunset()\nscene = Scene.with_grid(cols=12, rows=12, cell_size=25, background=colors.background)\n\nfor cell in scene.grid:\n    if (cell.row + cell.col) % 2 == 0:\n        cell.add_fill(color=colors.primary, opacity=0.7)\n    else:\n        cell.add_fill(color=colors.secondary, opacity=0.3)\n\nscene.save(\"pattern.svg\")\n</code></pre> <p></p> A warm checkerboard using the Sunset palette. <p></p>"},{"location":"getting-started/02-your-first-artwork/#add-shapes","title":"Add Shapes","text":"<p>Use <code>cell.normalized_position</code> to drive size, rotation, and opacity based on where each cell sits in the grid:</p> <pre><code>from pyfreeform import Polygon\n\nfor cell in scene.grid:\n    nx, ny = cell.normalized_position  # (1)!\n    t = (nx + ny) / 2\n    cell.add_polygon(\n        Polygon.diamond(size=0.3 + t * 0.5),\n        fill=colors.accent,\n        opacity=0.4 + t * 0.6,\n        rotation=t * 45,\n    )\n</code></pre> <ol> <li><code>normalized_position</code> returns (nx, ny) where both values range from 0.0 (top-left) to 1.0 (bottom-right).</li> </ol> <p></p> Diamonds that grow and rotate from corner to corner. <p></p>"},{"location":"getting-started/02-your-first-artwork/#layer-curves-for-flow","title":"Layer Curves for Flow","text":"<p>Stack curves on top for an organic finish:</p> <pre><code>import math\n\nfor cell in scene.grid:\n    nx, ny = cell.normalized_position\n    curvature = math.sin(nx * math.pi * 2) * 0.6\n    cell.add_curve(\n        start=\"left\", end=\"right\",\n        curvature=curvature,\n        width=0.8,\n        color=colors.line,\n        opacity=0.3 + ny * 0.4,\n    )\n</code></pre> <p></p> Curves add rhythm and movement to the geometric base. <p></p>"},{"location":"getting-started/02-your-first-artwork/#whats-next","title":"What's Next?","text":"<p>You've seen how PyFreeform turns a few lines of code into visual art. Now learn the concepts behind it:</p> <p>:octicons-arrow-right-24: How PyFreeform Works</p>"},{"location":"getting-started/03-how-it-works/","title":"How PyFreeform Works","text":""},{"location":"getting-started/03-how-it-works/#how-pyfreeform-works","title":"How PyFreeform Works","text":"<p>Understanding four concepts unlocks everything PyFreeform can do.</p>"},{"location":"getting-started/03-how-it-works/#the-mental-model","title":"The Mental Model","text":"<pre><code>Scene  \u2192  Grid  \u2192  Cells  \u2192  Entities\n</code></pre> <p>A Scene is your canvas. It contains a Grid of Cells. You add Entities (dots, lines, shapes, text) to each cell.</p> <p></p> A 6x6 grid with dots, lines, shapes, and fills placed in different cells. <p>Every cell inherits data from the image (if you used <code>from_image()</code>) \u2014 brightness, color, RGB values. Without an image, cells have neutral defaults. Either way, the pattern is always the same:</p> <pre><code>scene = Scene.from_image(\"photo.jpg\")  # or Scene.with_grid(...)\n\nfor cell in scene.grid:\n    # Read data from the cell\n    # Add entities based on that data\n    cell.add_dot(radius=cell.brightness * 5, color=cell.color)\n\nscene.save(\"output.svg\")\n</code></pre>"},{"location":"getting-started/03-how-it-works/#named-positions","title":"Named Positions","text":"<p>Every surface (cell, scene, merged region) has 9 named positions. Use them anywhere you'd specify a location:</p> <p></p> The 9 named positions: center, corners, and edge midpoints. <pre><code>cell.add_dot(at=\"center\")           # Default\ncell.add_dot(at=\"top_left\")         # Corner\ncell.add_line(start=\"left\", end=\"right\")  # Edge to edge\n</code></pre> <p>You can also use relative coordinates \u2014 <code>(0.0, 0.0)</code> is top-left, <code>(1.0, 1.0)</code> is bottom-right:</p> <pre><code>cell.add_dot(at=(0.25, 0.75))  # Quarter from left, three-quarters down\n</code></pre>"},{"location":"getting-started/03-how-it-works/#the-surface-protocol","title":"The Surface Protocol","text":"<p><code>Cell</code>, <code>Scene</code>, and <code>CellGroup</code> all share the same builder methods. This means you learn one set of methods and use them everywhere:</p> Method Creates <code>add_dot()</code> Filled circle <code>add_line()</code> Line segment <code>add_curve()</code> Bezier curve <code>add_ellipse()</code> Ellipse (also a path!) <code>add_polygon()</code> Any polygon shape <code>add_rect()</code> Rectangle <code>add_text()</code> Text label <code>add_path()</code> Smooth path from any parametric equation <code>add_fill()</code> Solid background fill <code>add_border()</code> Stroke-only border <p></p> Entities added at the cell level (dots) and scene level (large dot, line) coexist."},{"location":"getting-started/03-how-it-works/#layering-with-z_index","title":"Layering with z_index","text":"<p>When entities overlap, <code>z_index</code> controls which appears on top. Higher values render later (on top):</p> <pre><code>cell.add_fill(color=\"navy\", z_index=0)      # Background\ncell.add_ellipse(fill=\"coral\", z_index=1)    # Middle layer\ncell.add_dot(color=\"white\", z_index=2)       # Foreground\n</code></pre> <p></p> Four layers stacked: fill \u2192 ellipse \u2192 hexagon \u2192 dot. <p>Same z_index?</p> <p>Entities with the same <code>z_index</code> render in the order they were added.</p>"},{"location":"getting-started/03-how-it-works/#whats-next","title":"What's Next?","text":"<p>You now understand the core architecture. The Guide takes you through every feature in depth:</p> <p>:octicons-arrow-right-24: Scenes &amp; Grids</p>"},{"location":"guide/","title":"Guide","text":""},{"location":"guide/#guide","title":"Guide","text":"<p>The learning path. Each page introduces new concepts through visual examples, building on what came before.</p> Page You'll Learn Scenes &amp; Grids Creating scenes, grid parameters, selections Working with Cells Cell data, brightness, neighbors, sampling Drawing with Entities All 8 entity types in creative contexts Colors, Styles &amp; Palettes Color system, style objects, palettes Paths &amp; Parametric Positioning The along/t system, pathables, text paths Shapes &amp; Polygons Shape classmethods, EntityGroups, fitting Text &amp; Typography Text placement, fonts, text along paths Transforms &amp; Layout Rotation, scaling, fitting, connections, anchors"},{"location":"guide/01-scenes-and-grids/","title":"Scenes & Grids","text":""},{"location":"guide/01-scenes-and-grids/#scenes-grids","title":"Scenes &amp; Grids","text":"<p>The Scene is your canvas, and the Grid gives it structure. Together they form the foundation of every PyFreeform artwork.</p>"},{"location":"guide/01-scenes-and-grids/#creating-scenes","title":"Creating Scenes","text":""},{"location":"guide/01-scenes-and-grids/#from-an-image","title":"From an Image","text":"<p><code>Scene.from_image()</code> loads a photo and divides it into a grid of cells, each sampling the image's colors and brightness.</p> <pre><code>from pyfreeform import Scene\n\nscene = Scene.from_image(\"MonaLisa.jpg\", grid_size=40, cell_size=10)\n</code></pre> <p><code>grid_size</code> controls resolution \u2014 how many columns of cells across. More cells = more detail:</p> <p></p> <code>grid_size=20</code> <p></p> <code>grid_size=40</code> <p></p> <code>grid_size=60</code>"},{"location":"guide/01-scenes-and-grids/#cell-ratio","title":"Cell Ratio","text":"<p><code>cell_ratio</code> changes cell proportions. A ratio of 2.0 makes cells twice as wide as tall:</p> <p></p> <code>cell_ratio=1.0</code> (square) <p></p> <code>cell_ratio=2.0</code> (wide) <p></p> <code>cell_ratio=0.5</code> (tall)"},{"location":"guide/01-scenes-and-grids/#from-scratch","title":"From Scratch","text":"<p><code>Scene.with_grid()</code> creates a grid with no image data \u2014 use position and math to drive visuals:</p> <pre><code>from pyfreeform import Scene, Palette\n\ncolors = Palette.midnight()\nscene = Scene.with_grid(cols=15, rows=15, cell_size=22, background=colors.background)\n\nfor cell in scene.grid:\n    nx, ny = cell.normalized_position\n    radius = 2 + (nx * ny) * 8\n    cell.add_dot(radius=radius, color=colors.primary, opacity=0.5 + nx * 0.5)\n</code></pre> <p></p> Dot size grows with position \u2014 no image needed."},{"location":"guide/01-scenes-and-grids/#grid-selections","title":"Grid Selections","text":"<p>The grid offers powerful selection methods for targeting specific cells.</p>"},{"location":"guide/01-scenes-and-grids/#row-column","title":"Row &amp; Column","text":"<pre><code>for cell in scene.grid.row(3):        # All cells in row 3\n    cell.add_fill(color=colors.primary, opacity=0.4)\n\nfor cell in scene.grid.column(6):     # All cells in column 6\n    cell.add_fill(color=colors.accent, opacity=0.4)\n</code></pre> Row 3 in coral, column 6 in amber, intersection highlighted."},{"location":"guide/01-scenes-and-grids/#border","title":"Border","text":"<pre><code>for cell in scene.grid.border(thickness=2):  # (1)!\n    cell.add_fill(color=colors.accent, opacity=0.7)\n</code></pre> <ol> <li><code>thickness</code> controls how many rows/columns deep the border extends.</li> </ol> The outer 2 rows/columns highlighted as a border."},{"location":"guide/01-scenes-and-grids/#region","title":"Region","text":"<pre><code>for cell in scene.grid.region(2, 6, 3, 9):  # (1)!\n    cell.add_polygon(Polygon.hexagon(size=0.6), fill=colors.primary)\n</code></pre> <ol> <li><code>region(row_start, row_end, col_start, col_end)</code> \u2014 end is exclusive.</li> </ol> Hexagons placed only in the selected rectangular region."},{"location":"guide/01-scenes-and-grids/#checkerboard-diagonal","title":"Checkerboard &amp; Diagonal","text":"<pre><code>for cell in scene.grid.checkerboard(\"black\"):\n    cell.add_polygon(Polygon.diamond(size=0.7), fill=colors.primary)\n\nfor cell in scene.grid.checkerboard(\"white\"):\n    cell.add_dot(radius=4, color=colors.accent)\n</code></pre> Checkerboard: diamonds and dots alternate. Every 3rd diagonal highlighted with fills."},{"location":"guide/01-scenes-and-grids/#merging-cells","title":"Merging Cells","text":"<p>Merge a row, column, or rectangular region into a single CellGroup \u2014 a virtual surface that spans multiple cells:</p> <pre><code>title_bar = scene.grid.merge_row(0)\ntitle_bar.add_fill(color=colors.primary, opacity=0.2)\ntitle_bar.add_text(\"TITLE BAR\", at=\"center\", font_size=14, color=colors.accent, bold=True)\n</code></pre> <p></p> Row 0 merged into a CellGroup with text overlay. <p>A CellGroup has all the same <code>add_*</code> methods as a Cell \u2014 it's a full Surface.</p> <p>Other merge methods</p> <ul> <li><code>grid.merge_col(i)</code> \u2014 merge a full column</li> <li><code>grid.merge(row_start, row_end, col_start, col_end)</code> \u2014 merge any rectangular region</li> </ul>"},{"location":"guide/01-scenes-and-grids/#whats-next","title":"What's Next?","text":"<p>Now that you can create and navigate grids, learn how to read and use each cell's data:</p> <p>:octicons-arrow-right-24: Working with Cells</p>"},{"location":"guide/02-working-with-cells/","title":"Working with Cells","text":""},{"location":"guide/02-working-with-cells/#working-with-cells","title":"Working with Cells","text":"<p>Every cell in the grid carries data \u2014 brightness, color, position \u2014 and you use that data to drive your art.</p>"},{"location":"guide/02-working-with-cells/#cell-data-properties","title":"Cell Data Properties","text":"<p>When a scene is created with <code>from_image()</code>, each cell samples the pixels beneath it:</p> Property Type Range Description <code>cell.brightness</code> <code>float</code> 0.0 \u2013 1.0 Perceived luminance (0 = black, 1 = white) <code>cell.color</code> <code>str</code> Hex string Average color as <code>\"#rrggbb\"</code> <code>cell.rgb</code> <code>tuple</code> (0-255, 0-255, 0-255) RGB components <code>cell.alpha</code> <code>float</code> 0.0 \u2013 1.0 Opacity from source image <p>No image?</p> <p>Cells from <code>Scene.with_grid()</code> default to brightness 0.5, color <code>\"#808080\"</code>. Use <code>normalized_position</code>, math, or <code>distance_to()</code> instead.</p>"},{"location":"guide/02-working-with-cells/#brightness-driven-effects","title":"Brightness-Driven Effects","text":""},{"location":"guide/02-working-with-cells/#size-by-brightness","title":"Size by Brightness","text":"<p>The most classic effect \u2014 bright areas get larger marks:</p> <pre><code>scene = Scene.from_image(\"MonaLisa.jpg\", grid_size=40, cell_size=10)\n\nfor cell in scene.grid:\n    r = cell.brightness * scene.grid.cell_width * 0.48\n    if r &gt; 0.3:\n        cell.add_dot(radius=r, color=\"#ffffff\")\n</code></pre> <p></p> White dots sized by brightness \u2014 the classic dot art look."},{"location":"guide/02-working-with-cells/#rotation-by-brightness","title":"Rotation by Brightness","text":"<p>Drive shape rotation from the image:</p> <pre><code>for cell in scene.grid:\n    rotation = cell.brightness * 90\n    size = 0.4 + cell.brightness * 0.4\n    cell.add_polygon(\n        Polygon.square(size=size),\n        fill=cell.color,\n        opacity=0.7,\n        rotation=rotation,\n    )\n</code></pre> <p></p> Squares rotate and grow with brightness, colored by the source image."},{"location":"guide/02-working-with-cells/#color-fill","title":"Color Fill","text":"<p>The simplest approach \u2014 fill each cell with its sampled color:</p> <pre><code>for cell in scene.grid:\n    cell.add_fill(color=cell.color)\n</code></pre> <p></p> A gradient image reproduced as a pixelated color mosaic."},{"location":"guide/02-working-with-cells/#neighbors-and-edge-detection","title":"Neighbors and Edge Detection","text":"<p>Every cell knows its 8 neighbors:</p> <pre><code>cell.above          # Cell | None\ncell.below          # Cell | None\ncell.left           # Cell | None\ncell.right          # Cell | None\ncell.above_left     # Cell | None  (diagonal)\ncell.above_right    # Cell | None\ncell.below_left     # Cell | None\ncell.below_right    # Cell | None\n</code></pre> <p>Comparing a cell's brightness to its neighbors reveals edges:</p> <pre><code>for cell in scene.grid:\n    edge = 0.0\n    if cell.right:\n        edge += abs(cell.brightness - cell.right.brightness)\n    if cell.below:\n        edge += abs(cell.brightness - cell.below.brightness)\n    edge = min(edge * 3, 1.0)  # Amplify\n    if edge &gt; 0.1:\n        cell.add_dot(radius=edge * 3.5, color=\"#00d9ff\", opacity=edge)\n</code></pre> <p></p> Edges glow cyan \u2014 only cells where brightness changes sharply get marks."},{"location":"guide/02-working-with-cells/#position-based-effects","title":"Position-Based Effects","text":""},{"location":"guide/02-working-with-cells/#distance-to-a-point","title":"Distance to a Point","text":"<p><code>cell.distance_to()</code> measures pixel distance to any cell, point, or coordinate:</p> <pre><code>center = scene.grid[10, 10]\nmax_d = center.distance_to(scene.grid[0, 0])\n\nfor cell in scene.grid:\n    d = cell.distance_to(center)\n    t = 1 - (d / max_d)  # 1 at center, 0 at corners\n    cell.add_dot(radius=t * 7, color=colors.primary, opacity=0.3 + t * 0.7)\n</code></pre> <p></p> Dots fade and shrink with distance from the center cell."},{"location":"guide/02-working-with-cells/#normalized-position","title":"Normalized Position","text":"<p><code>cell.normalized_position</code> returns <code>(nx, ny)</code> where both range from 0.0 (top-left) to 1.0 (bottom-right):</p> <pre><code>for cell in scene.grid:\n    nx, ny = cell.normalized_position\n    size = 0.3 + ny * 0.5   # Grow downward\n    # ... color gradient from left to right\n</code></pre> <p></p> Diamonds grow downward, colors shift from left to right."},{"location":"guide/02-working-with-cells/#sub-cell-sampling","title":"Sub-Cell Sampling","text":"<p>For higher-detail effects, sample the image at multiple points within each cell:</p> <pre><code>for cell in scene.grid:\n    for (rx, ry), pos in [\n        ((0.25, 0.25), \"top_left\"),\n        ((0.75, 0.25), \"top_right\"),\n        ((0.25, 0.75), \"bottom_left\"),\n        ((0.75, 0.75), \"bottom_right\"),\n    ]:\n        color = cell.sample_hex(rx, ry)      # (1)!\n        brightness = cell.sample_brightness(rx, ry)\n        cell.add_dot(at=pos, radius=brightness * 3.5, color=color)\n</code></pre> <ol> <li><code>sample_hex(rx, ry)</code> reads the pixel at relative position (rx, ry) within the cell. Only works with <code>from_image()</code>.</li> </ol> <p></p> 4 dots per cell, each sampling a different quadrant \u2014 effectively 4x resolution."},{"location":"guide/02-working-with-cells/#filtering-with-where","title":"Filtering with <code>where()</code>","text":"<p>Use <code>grid.where()</code> to select cells by any condition:</p> <pre><code># Dark cells get fills, bright cells get stars\nfor cell in scene.grid.where(lambda c: c.brightness &lt; 0.4):\n    cell.add_fill(color=cell.color, opacity=0.5)\n\nfor cell in scene.grid.where(lambda c: c.brightness &gt;= 0.4):\n    cell.add_polygon(\n        Polygon.star(points=4, size=0.3 + cell.brightness * 0.5),\n        fill=cell.color, opacity=0.7,\n    )\n</code></pre> <p></p> Different treatments for dark (fills) and bright (stars) cells."},{"location":"guide/02-working-with-cells/#whats-next","title":"What's Next?","text":"<p>You've mastered reading cell data. Now learn all the entity types you can place in cells:</p> <p>:octicons-arrow-right-24: Drawing with Entities</p>"},{"location":"guide/03-drawing-with-entities/","title":"Drawing with Entities","text":""},{"location":"guide/03-drawing-with-entities/#drawing-with-entities","title":"Drawing with Entities","text":"<p>PyFreeform has 8 entity types, each with a unique creative personality. This page showcases what makes each one special.</p>"},{"location":"guide/03-drawing-with-entities/#dots","title":"Dots","text":"<p>The fundamental mark. A filled circle defined by radius and color.</p> <pre><code>cell.add_dot(radius=cell.brightness * 5, color=cell.color, opacity=0.6)\n</code></pre> <p></p> Dots sized and colored by a gradient image \u2014 larger and brighter toward the warm corner. <p>Key parameter</p> <p>Dots use <code>color=</code> (not <code>fill=</code>). Default radius is 5.</p>"},{"location":"guide/03-drawing-with-entities/#lines","title":"Lines","text":"<p>Structure and direction. Line segments connect two points within a cell.</p> <pre><code>angle = math.sin(nx * math.pi * 2) * 0.4\ndx, dy = math.cos(angle) * 0.4, math.sin(angle) * 0.4\ncell.add_line(start=(0.5 - dx, 0.5 - dy), end=(0.5 + dx, 0.5 + dy), width=1.5, color=colors.primary)\n</code></pre> <p></p> Line angles driven by sine waves create a flowing direction field. <p>Lines also implement the Pathable protocol \u2014 you can position other entities along them with <code>along=line, t=0.5</code>.</p>"},{"location":"guide/03-drawing-with-entities/#curves","title":"Curves","text":"<p>Organic flow. Quadratic Bezier curves with controllable curvature.</p> <pre><code>curvature = math.sin(nx * math.pi * 3 + ny * 2) * 0.8\ncell.add_curve(start=\"bottom_left\", end=\"top_right\", curvature=curvature, width=1.5, color=colors.primary)\n</code></pre> <p></p> Varying curvature across the grid creates a rippling wave texture. <p>Curvature values</p> <p><code>0</code> = straight line. Positive = bows left. Negative = bows right. Typical range: -1 to 1.</p>"},{"location":"guide/03-drawing-with-entities/#ellipses","title":"Ellipses","text":"<p>The pathable shape. Ellipses can serve as both visual elements and paths for positioning.</p> <pre><code>cell.add_ellipse(at=\"center\", rx=10, ry=5, rotation=(nx + ny) * 90, fill=colors.primary, opacity=0.6)\n</code></pre> <p></p> Ellipses rotated by position create a moir\u00e9 interference pattern. <p>Ellipses use <code>fill=</code> (not <code>color=</code>) and support <code>stroke</code>, <code>fill_opacity</code>, and <code>stroke_opacity</code>.</p>"},{"location":"guide/03-drawing-with-entities/#rectangles","title":"Rectangles","text":"<p>Filled regions with optional rotation. <code>at=</code> specifies the center position.</p> <pre><code>cell.add_rect(at=\"center\", width=w, height=h, rotation=t * 45, fill=colors.primary, opacity=0.5)\n</code></pre> <p></p> Rectangles with varying proportions and rotation form an evolving mosaic."},{"location":"guide/03-drawing-with-entities/#polygons","title":"Polygons","text":"<p>Shape variety. Use the shape classmethods for common shapes, or pass custom vertices.</p> <pre><code>if brightness &lt; 0.25:\n    verts = Polygon.triangle(size=size)\nelif brightness &lt; 0.5:\n    verts = Polygon.diamond(size=size)\nelif brightness &lt; 0.75:\n    verts = Polygon.hexagon(size=size)\nelse:\n    verts = Polygon.star(points=5, size=size)\n\ncell.add_polygon(verts, fill=cell.color, opacity=0.8)\n</code></pre> <p></p> Different shapes for different brightness ranges \u2014 triangles, diamonds, hexagons, and stars. All shape classmethods Method Shape <code>Polygon.triangle()</code> Equilateral triangle <code>Polygon.square()</code> Square <code>Polygon.diamond()</code> Rotated square <code>Polygon.hexagon()</code> Regular hexagon <code>Polygon.star(points=5)</code> N-pointed star <code>Polygon.regular_polygon(sides)</code> Regular N-gon <code>Polygon.squircle()</code> Superellipse <code>Polygon.rounded_rect()</code> Rounded rectangle"},{"location":"guide/03-drawing-with-entities/#text","title":"Text","text":"<p>Labels, characters, and typography. Supports font families, bold, italic, rotation.</p> <pre><code>cell.add_text(\"A\", at=\"center\", font_size=20, color=colors.primary, bold=True, opacity=0.7)\n</code></pre> <p></p> Characters from \"PYFREEFORM\" repeated across the grid, growing in size."},{"location":"guide/03-drawing-with-entities/#paths","title":"Paths","text":"<p>Render any parametric equation as a smooth SVG path. Define a class with <code>point_at(t)</code> and pass it to <code>add_path()</code>:</p> <pre><code>class Spiral:\n    def __init__(self, cx, cy, max_r, turns=2):\n        self.cx, self.cy, self.max_r, self.turns = cx, cy, max_r, turns\n\n    def point_at(self, t):\n        angle = t * self.turns * 2 * math.pi\n        r = t * self.max_r\n        return Point(self.cx + r * math.cos(angle), self.cy + r * math.sin(angle))\n\nspiral = Spiral(cx, cy, max_r=12, turns=3)\ncell.add_path(spiral, segments=48, width=1.2, color=colors.primary)\n</code></pre> <p></p> A custom spiral pathable rendered in each cell \u2014 the path system handles any shape."},{"location":"guide/03-drawing-with-entities/#whats-next","title":"What's Next?","text":"<p>Now that you know all the entity types, learn how to color and style them consistently:</p> <p>:octicons-arrow-right-24: Colors, Styles &amp; Palettes</p>"},{"location":"guide/04-colors-styles-palettes/","title":"Colors, Styles & Palettes","text":""},{"location":"guide/04-colors-styles-palettes/#colors-styles-palettes","title":"Colors, Styles &amp; Palettes","text":"<p>PyFreeform provides a coherent color and styling system. Master three concepts: the color parameter split, style objects, and palettes.</p>"},{"location":"guide/04-colors-styles-palettes/#the-color-parameter-split","title":"The Color Parameter Split","text":"<p>This is the most important API distinction to remember:</p> Parameter Used by Description <code>color=</code> Dot, Line, Curve, Text, <code>add_fill</code>, <code>add_border</code> Stroke-like entities <code>fill=</code> Rect, Ellipse, Polygon Filled shapes <p></p> Top row: entities using <code>color=</code>. Bottom row: entities using <code>fill=</code>. <p>Common mistake</p> <p>Writing <code>cell.add_polygon(verts, color=\"red\")</code> will raise an error. Use <code>fill=\"red\"</code> for shapes.</p>"},{"location":"guide/04-colors-styles-palettes/#color-formats","title":"Color Formats","text":"<p>All color parameters accept:</p> <ul> <li>Named colors: <code>\"red\"</code>, <code>\"coral\"</code>, <code>\"navy\"</code>, <code>\"salmon\"</code></li> <li>Hex strings: <code>\"#ff6b6b\"</code>, <code>\"#f00\"</code>, <code>\"#FF6B6B\"</code></li> <li>RGB tuples: Colors from <code>cell.rgb</code> can be formatted to hex with <code>cell.color</code></li> </ul>"},{"location":"guide/04-colors-styles-palettes/#opacity","title":"Opacity","text":"<p>Every entity supports <code>opacity</code> (0.0 transparent \u2192 1.0 opaque, default 1.0):</p> <pre><code>cell.add_dot(radius=10, color=\"coral\", opacity=0.5)\ncell.add_fill(color=\"navy\", opacity=0.3)\n</code></pre>"},{"location":"guide/04-colors-styles-palettes/#shape-specific-fill_opacity-stroke_opacity","title":"Shape-Specific: fill_opacity &amp; stroke_opacity","text":"<p>Shapes (Rect, Ellipse, Polygon) support independent opacity for fill and stroke:</p> <pre><code>cell.add_ellipse(\n    rx=22, ry=22,\n    fill=colors.primary,\n    stroke=colors.accent,\n    stroke_width=3,\n    fill_opacity=0.4,     # Semi-transparent fill\n    stroke_opacity=1.0,   # Fully opaque stroke\n)\n</code></pre> <p></p> Fill opacity from 0.2 to 1.0 with constant stroke opacity."},{"location":"guide/04-colors-styles-palettes/#layered-opacity","title":"Layered Opacity","text":"<p>Stack semi-transparent shapes for color mixing effects:</p> <p></p> Three overlapping circles at 50% opacity \u2014 colors blend where they overlap."},{"location":"guide/04-colors-styles-palettes/#style-objects","title":"Style Objects","text":"<p>Instead of repeating parameters, define a style object once and reuse it:</p> <pre><code>from pyfreeform import DotStyle, LineStyle, ShapeStyle\n\ndot_small = DotStyle(radius=3, color=\"coral\", opacity=0.6)\ndot_large = DotStyle(radius=7, color=\"gold\", opacity=0.9)\nline_thin = LineStyle(width=1, color=\"#666688\", opacity=0.4)\nshape_hex = ShapeStyle(color=\"teal\", opacity=0.5)\n\nfor cell in scene.grid:\n    cell.add_dot(style=dot_small)               # Apply directly\n    cell.add_line(start=\"top\", end=\"bottom\", style=line_thin)\n</code></pre> <p></p> Three zones using different pre-defined styles \u2014 consistent look with no parameter repetition."},{"location":"guide/04-colors-styles-palettes/#all-style-classes","title":"All Style Classes","text":"Class For Methods Key Fields <code>DotStyle</code> <code>add_dot()</code> <code>radius</code>, <code>color</code>, <code>opacity</code> <code>LineStyle</code> <code>add_line()</code>, <code>add_diagonal()</code>, <code>add_curve()</code>, <code>add_path()</code> <code>width</code>, <code>color</code>, <code>cap</code>, <code>start_cap</code>, <code>end_cap</code> <code>FillStyle</code> <code>add_fill()</code> <code>color</code>, <code>opacity</code> <code>BorderStyle</code> <code>add_border()</code> <code>width</code>, <code>color</code>, <code>opacity</code> <code>ShapeStyle</code> <code>add_ellipse()</code>, <code>add_polygon()</code>, <code>add_rect()</code> <code>color</code> (\u2192 fill), <code>stroke</code>, <code>stroke_width</code> <code>TextStyle</code> <code>add_text()</code> <code>font_size</code>, <code>color</code>, <code>font_family</code>, <code>bold</code>, <code>italic</code> <code>ConnectionStyle</code> <code>Connection</code> <code>width</code>, <code>color</code>, <code>cap</code>"},{"location":"guide/04-colors-styles-palettes/#builder-methods","title":"Builder Methods","text":"<p>Styles are immutable. Use <code>.with_*()</code> to create modified copies:</p> <pre><code>base = LineStyle(width=2, color=\"coral\")\nthick = base.with_width(4)          # New style, width=4\narrow = base.with_end_cap(\"arrow\")  # New style, with arrow cap\n</code></pre>"},{"location":"guide/04-colors-styles-palettes/#palettes","title":"Palettes","text":"<p>8 pre-built color palettes with 6 named colors each:</p> <p></p> Midnight <p></p> Sunset <p></p> Ocean <p></p> Forest <p></p> Monochrome <p></p> Paper <p></p> Neon <p></p> Pastel"},{"location":"guide/04-colors-styles-palettes/#using-palettes","title":"Using Palettes","text":"<pre><code>from pyfreeform import Palette\n\ncolors = Palette.midnight()\nscene = Scene.with_grid(cols=10, rows=10, cell_size=20, background=colors.background)\n\nfor cell in scene.grid:\n    cell.add_dot(color=colors.primary)\n    cell.add_border(color=colors.grid, width=0.3)\n</code></pre>"},{"location":"guide/04-colors-styles-palettes/#named-colors","title":"Named Colors","text":"Name Purpose <code>colors.background</code> Scene background <code>colors.primary</code> Main element color <code>colors.secondary</code> Supporting element color <code>colors.accent</code> Highlight/emphasis color <code>colors.line</code> Lines and connections <code>colors.grid</code> Grid borders"},{"location":"guide/04-colors-styles-palettes/#custom-palettes","title":"Custom Palettes","text":"<pre><code>my_palette = Palette(\n    background=\"#1a1a2e\",\n    primary=\"#ff6b6b\",\n    secondary=\"#4ecdc4\",\n    accent=\"#ffe66d\",\n    line=\"#666688\",\n    grid=\"#3d3d5c\",\n)\n</code></pre> <p>Utilities: <code>colors.with_background(\"#000\")</code>, <code>colors.inverted()</code>, <code>colors.all_colors()</code>.</p>"},{"location":"guide/04-colors-styles-palettes/#whats-next","title":"What's Next?","text":"<p>Learn the \"killer feature\" \u2014 positioning entities along any path:</p> <p>:octicons-arrow-right-24: Paths &amp; Parametric Positioning</p>"},{"location":"guide/05-paths-and-parametric/","title":"Paths & Parametric Positioning","text":""},{"location":"guide/05-paths-and-parametric/#paths-parametric-positioning","title":"Paths &amp; Parametric Positioning","text":"<p>This is PyFreeform's \"killer feature\" \u2014 position any entity at any point along any path using the <code>along</code> / <code>t</code> system.</p>"},{"location":"guide/05-paths-and-parametric/#the-core-idea","title":"The Core Idea","text":"<p>Every Line, Curve, and Ellipse is a Pathable \u2014 it has a <code>point_at(t)</code> method where <code>t</code> goes from 0.0 (start) to 1.0 (end). You can place entities along these paths:</p> <pre><code>line = cell.add_diagonal()\ncell.add_dot(along=line, t=cell.brightness)  # (1)!\n</code></pre> <ol> <li>The dot's position slides along the diagonal based on brightness.</li> </ol> <p></p> Each dot slides along its cell's diagonal \u2014 bright areas push dots toward the top-right."},{"location":"guide/05-paths-and-parametric/#along-curves","title":"Along Curves","text":"<p>Curves make the positioning non-linear and organic:</p> <pre><code>curve = cell.add_curve(start=\"bottom_left\", end=\"top_right\", curvature=0.6, ...)\nfor t_val in [0.25, 0.5, 0.75]:\n    cell.add_dot(along=curve, t=t_val, radius=2, color=colors.primary)\n</code></pre> <p></p> Three dots per cell positioned along curves \u2014 the Bezier shape creates smooth distribution."},{"location":"guide/05-paths-and-parametric/#along-ellipses","title":"Along Ellipses","text":"<p>Ellipses are closed paths \u2014 <code>t=0</code> is the rightmost point, going counterclockwise:</p> t value Position 0.0 Right 0.25 Top 0.5 Left 0.75 Bottom <pre><code>ellipse = cell.add_ellipse(at=\"center\", rx=10, ry=6, fill=\"none\", stroke=colors.line)\ncell.add_dot(along=ellipse, t=ny, radius=3, color=colors.accent)\n</code></pre> <p></p> Each dot orbits its cell's ellipse at a position driven by the row."},{"location":"guide/05-paths-and-parametric/#understanding-t-values","title":"Understanding t Values","text":"<p>On a single path, <code>t</code> selects the position:</p> <p></p> Five dots at t=0.00, 0.25, 0.50, 0.75, and 1.00 along a curve."},{"location":"guide/05-paths-and-parametric/#custom-pathables","title":"Custom Pathables","text":"<p>Any object with <code>point_at(t) \u2192 Point</code> works as a path. Create your own:</p> <pre><code>from pyfreeform import Point\n\nclass Wave:\n    def __init__(self, x1, y1, x2, y2, amplitude, frequency):\n        self.x1, self.y1, self.x2, self.y2 = x1, y1, x2, y2\n        self.amp, self.freq = amplitude, frequency\n\n    def point_at(self, t):\n        x = self.x1 + t * (self.x2 - self.x1)\n        cy = self.y1 + t * (self.y2 - self.y1)\n        y = cy + self.amp * math.sin(t * self.freq * 2 * math.pi)\n        return Point(x, y)\n</code></pre> <p>Render it with <code>add_path()</code>:</p> <pre><code>wave = Wave(cx - 10, cy, cx + 10, cy, amplitude=8, frequency=3)\ncell.add_path(wave, segments=32, width=1.5, color=colors.primary)\n</code></pre> <p></p> Wave paths with increasing frequency across the grid."},{"location":"guide/05-paths-and-parametric/#sub-paths-and-arcs","title":"Sub-Paths and Arcs","text":"<p>Use <code>start_t</code> and <code>end_t</code> to render only a portion of a path:</p> <pre><code>cell.add_path(\n    ellipse,\n    start_t=0.1,      # Start at 10% around\n    end_t=0.6,         # End at 60% around\n    segments=24,\n    width=2,\n    color=colors.primary,\n)\n</code></pre> <p></p> Partial arcs of ellipses \u2014 the start and length vary by position."},{"location":"guide/05-paths-and-parametric/#text-along-paths","title":"Text Along Paths","text":"<p>Pass a path to <code>add_text(along=)</code> without <code>t</code> to warp text along the full path:</p> <pre><code>curve = cell.add_curve(start=(0.05, 0.7), end=(0.95, 0.3), curvature=0.5, ...)\ncell.add_text(\"Text flows along any path\", along=curve, font_size=14, color=colors.accent)\n</code></pre> <p></p> Text automatically warped along a Bezier curve using SVG <code>&lt;textPath&gt;</code>. <p></p>"},{"location":"guide/05-paths-and-parametric/#alignment","title":"Alignment","text":"<p>Set <code>align=True</code> to rotate entities to follow the path's tangent direction:</p> <pre><code>cell.add_polygon(\n    Polygon.triangle(size=0.06),\n    along=curve, t=0.5, align=True,  # (1)!\n    fill=colors.primary,\n)\n</code></pre> <ol> <li>The triangle points in the direction the curve is heading at <code>t=0.5</code>.</li> </ol> <p></p> Triangles aligned to the curve's tangent \u2014 they point the way the path flows."},{"location":"guide/05-paths-and-parametric/#whats-next","title":"What's Next?","text":"<p>Explore the shape system and learn to compose reusable groups:</p> <p>:octicons-arrow-right-24: Shapes &amp; Polygons</p>"},{"location":"guide/06-shapes-and-polygons/","title":"Shapes & Polygons","text":""},{"location":"guide/06-shapes-and-polygons/#shapes-polygons","title":"Shapes &amp; Polygons","text":"<p>PyFreeform includes 8 built-in shape classmethods and a powerful EntityGroup system for composing your own.</p>"},{"location":"guide/06-shapes-and-polygons/#shape-gallery","title":"Shape Gallery","text":"<p>All shapes are created as vertex lists and passed to <code>add_polygon()</code>:</p> <pre><code>from pyfreeform import Polygon\n\ncell.add_polygon(Polygon.hexagon(size=0.7), fill=\"coral\")\ncell.add_polygon(Polygon.star(points=5, size=0.7), fill=\"gold\")\n</code></pre> <p></p> All 8 shape classmethods: triangle, square, diamond, hexagon, star, octagon, squircle, rounded rect."},{"location":"guide/06-shapes-and-polygons/#available-shapes","title":"Available Shapes","text":"Method Description <code>Polygon.triangle(size=0.8)</code> Equilateral triangle <code>Polygon.square(size=0.8)</code> Axis-aligned square <code>Polygon.diamond(size=0.8)</code> 45-degree rotated square <code>Polygon.hexagon(size=0.8)</code> Regular hexagon <code>Polygon.star(points=5, inner_ratio=0.4)</code> N-pointed star <code>Polygon.regular_polygon(sides, size=0.8)</code> Any regular N-gon <code>Polygon.squircle(size=0.8, n=4)</code> Superellipse (n=2: circle, n=4: squircle) <code>Polygon.rounded_rect(corner_radius=0.2)</code> Rectangle with rounded corners <p>All return <code>list[tuple[float, float]]</code> in relative coordinates (0-1), ready for any cell size.</p>"},{"location":"guide/06-shapes-and-polygons/#creative-applications","title":"Creative Applications","text":""},{"location":"guide/06-shapes-and-polygons/#hexagonal-tiling","title":"Hexagonal Tiling","text":"<pre><code>for cell in scene.grid:\n    cell.add_polygon(\n        Polygon.hexagon(size=0.85),\n        fill=colors.primary,\n        stroke=colors.secondary,\n        stroke_width=0.5,\n        opacity=0.3 + t * 0.5,\n    )\n</code></pre> Hexagons with growing opacity create a dense tiling pattern."},{"location":"guide/06-shapes-and-polygons/#shape-by-brightness","title":"Shape by Brightness","text":"<p>Choose shapes based on image data:</p> <pre><code>for cell in scene.grid:\n    b = cell.brightness\n    if b &lt; 0.5:\n        verts = Polygon.star(points=5, size=0.4 + b)\n    else:\n        verts = Polygon.hexagon(size=0.4 + b * 0.4)\n    cell.add_polygon(verts, fill=cell.color)\n</code></pre> <p></p> Star size and inner ratio both driven by the source image's brightness."},{"location":"guide/06-shapes-and-polygons/#entitygroup","title":"EntityGroup","text":"<p>An EntityGroup is a composite entity \u2014 build it from simpler entities, then place it in any cell:</p> <pre><code>from pyfreeform import EntityGroup, Dot, Ellipse\n\ndef make_flower(petal_color, center_color):\n    group = EntityGroup()\n    for i in range(6):\n        angle = i * 60 * math.pi / 180\n        px, py = 12 * math.cos(angle), 12 * math.sin(angle)\n        group.add(Ellipse(px, py, rx=8, ry=4, rotation=i * 60, fill=petal_color, opacity=0.7))\n    group.add(Dot(0, 0, radius=5, color=center_color))\n    return group\n</code></pre> <p>Use it across cells:</p> <pre><code>for cell in scene.grid:\n    flower = make_flower(colors.primary, colors.accent)\n    cell.place(flower)\n    flower.fit_to_cell(0.85)\n</code></pre> <p></p> A flower EntityGroup placed in every cell \u2014 define once, use everywhere. <p>New instance per cell</p> <p>Always create a new EntityGroup for each cell. Groups placed in cells should not be reused directly \u2014 wrap creation in a factory function.</p>"},{"location":"guide/06-shapes-and-polygons/#fit_to_cell","title":"fit_to_cell","text":"<p>Auto-scale any entity or group to fit within its cell:</p> <pre><code>group = make_flower(...)\ncell.place(group)\ngroup.fit_to_cell(0.7)  # (1)!\n</code></pre> <ol> <li><code>0.7</code> means fill 70% of the cell's area.</li> </ol> <p></p> The same group at 30%, 50%, 70%, 90%, and 100% of cell size."},{"location":"guide/06-shapes-and-polygons/#with-rotation","title":"With Rotation","text":"<p><code>fit_to_cell</code> works correctly with rotated groups:</p> <p></p> Groups scaled to 75% and rotated by position \u2014 fitting accounts for rotation."},{"location":"guide/06-shapes-and-polygons/#whats-next","title":"What's Next?","text":"<p>Learn text placement, typography, and text-along-path effects:</p> <p>:octicons-arrow-right-24: Text &amp; Typography</p>"},{"location":"guide/07-text-and-typography/","title":"Text & Typography","text":""},{"location":"guide/07-text-and-typography/#text-typography","title":"Text &amp; Typography","text":"<p>Text in PyFreeform supports font families, bold/italic, rotation, and text-along-path warping.</p>"},{"location":"guide/07-text-and-typography/#basic-text","title":"Basic Text","text":"<pre><code>cell.add_text(\"Hello\", at=\"center\", font_size=16, color=\"white\")\n</code></pre>"},{"location":"guide/07-text-and-typography/#font-families","title":"Font Families","text":"sans-serif, serif, and monospace \u2014 the three standard SVG font families."},{"location":"guide/07-text-and-typography/#bold-italic","title":"Bold &amp; Italic","text":"<pre><code>cell.add_text(\"Art\", font_size=24, color=colors.primary, bold=True)\ncell.add_text(\"Art\", font_size=24, color=colors.primary, italic=True)\ncell.add_text(\"Art\", font_size=24, color=colors.primary, bold=True, italic=True)\n</code></pre> Normal, Bold, Italic, and Bold+Italic variants."},{"location":"guide/07-text-and-typography/#ascii-art-from-images","title":"ASCII Art from Images","text":"<p>Map brightness to characters for a classic ASCII art effect:</p> <pre><code>chars = \" .:-=+*#%@\"\n\nscene = Scene.from_image(\"MonaLisa.jpg\", grid_size=40, cell_size=10)\nfor cell in scene.grid:\n    idx = int(cell.brightness * (len(chars) - 1))\n    char = chars[idx]\n    if char != \" \":\n        cell.add_text(char, at=\"center\", font_size=9, color=cell.color, font_family=\"monospace\")\n</code></pre> <p></p> The Mona Lisa rendered in ASCII characters, colored by the source image."},{"location":"guide/07-text-and-typography/#rotating-text","title":"Rotating Text","text":"<pre><code>for cell in scene.grid:\n    nx, ny = cell.normalized_position\n    rotation = (nx + ny) * 90\n    cell.add_text(\"AB\", at=\"center\", font_size=12, color=colors.primary, rotation=rotation)\n</code></pre> Text rotation varies smoothly across the grid."},{"location":"guide/07-text-and-typography/#text-along-paths","title":"Text Along Paths","text":"<p>Use <code>along=</code> with a path to warp text along its shape:</p>"},{"location":"guide/07-text-and-typography/#along-a-curve","title":"Along a Curve","text":"<pre><code>curve = cell.add_curve(start=(0.05, 0.7), end=(0.95, 0.3), curvature=0.5, ...)\ncell.add_text(\"Text warps along curves beautifully\", along=curve, font_size=14, color=colors.accent)\n</code></pre> Text automatically sized and warped to follow a Bezier curve."},{"location":"guide/07-text-and-typography/#along-an-ellipse","title":"Along an Ellipse","text":"<pre><code>ellipse = cell.add_ellipse(at=\"center\", rx=100, ry=60, fill=\"none\", stroke=colors.line)\ncell.add_text(\"Text flows around an ellipse path\", along=ellipse, font_size=13, color=colors.primary)\n</code></pre> Text wrapping around an elliptical path. <p>How it works</p> <p>When you pass <code>along=</code> without <code>t</code>, PyFreeform uses SVG <code>&lt;textPath&gt;</code> to warp text. The font size auto-adjusts to fill the path length.</p>"},{"location":"guide/07-text-and-typography/#title-overlays","title":"Title Overlays","text":"<p>Merge cells and overlay text on an artwork:</p> <pre><code>scene = Scene.from_image(\"FrankMonster.png\", grid_size=30, cell_size=12)\nfor cell in scene.grid:\n    cell.add_dot(radius=cell.brightness * 5, color=cell.color, opacity=0.7)\n\n# Merge bottom rows for a title bar\ntitle = scene.grid.merge(scene.grid.rows - 3, scene.grid.rows, 0, scene.grid.cols)\ntitle.add_fill(color=\"#000000\", opacity=0.5)\ntitle.add_text(\"FRANK\", at=\"center\", font_size=20, color=\"#ffffff\", bold=True)\n</code></pre> <p></p> A semi-transparent title bar overlaid on dot art using a merged CellGroup."},{"location":"guide/07-text-and-typography/#whats-next","title":"What's Next?","text":"<p>Master transforms, fitting, connections, and layout:</p> <p>:octicons-arrow-right-24: Transforms &amp; Layout</p>"},{"location":"guide/08-transforms-and-layout/","title":"Transforms & Layout","text":""},{"location":"guide/08-transforms-and-layout/#transforms-layout","title":"Transforms &amp; Layout","text":"<p>Rotate, scale, fit, connect, and layer entities for precise control over your compositions.</p>"},{"location":"guide/08-transforms-and-layout/#rotation","title":"Rotation","text":"<p>Every entity supports <code>rotation</code> as a parameter or <code>.rotate()</code> method:</p> <pre><code>cell.add_polygon(\n    Polygon.square(size=0.6),\n    fill=colors.primary,\n    rotation=(nx + ny) * 180,\n)\n</code></pre> <p></p> Squares rotate smoothly from 0 to 360 degrees across the grid."},{"location":"guide/08-transforms-and-layout/#scaling-with-fit_to_cell","title":"Scaling with fit_to_cell","text":"<p><code>entity.fit_to_cell(scale)</code> auto-sizes any entity to fit within its cell. <code>scale</code> is the fraction of cell area to fill (0.0 to 1.0):</p> <p></p> The same group at 20%, 40%, 60%, 80%, 90%, and 100% of cell size."},{"location":"guide/08-transforms-and-layout/#position-aware-fitting","title":"Position-Aware Fitting","text":"<p>Pass <code>at=(rx, ry)</code> to fit at a specific position within the cell:</p> <pre><code>group.fit_to_cell(0.5, at=(0.15, 0.15))   # Near top-left, constrained by edges\ngroup.fit_to_cell(0.5, at=(0.5, 0.5))     # Centered\ngroup.fit_to_cell(0.5, at=(0.85, 0.85))   # Near bottom-right\n</code></pre> <p></p> Same size, different positions \u2014 the entity respects cell boundaries."},{"location":"guide/08-transforms-and-layout/#connections","title":"Connections","text":"<p>Link entities with Connection objects that auto-update when entities move:</p> <pre><code>from pyfreeform import ConnectionStyle\n\ndot1 = cell_a.add_dot(radius=5, color=\"coral\")\ndot2 = cell_b.add_dot(radius=5, color=\"coral\")\n\nconn = dot1.connect(dot2, style=ConnectionStyle(width=1, color=\"gray\"))\nscene.add(conn)  # (1)!\n</code></pre> <ol> <li>Connections must be added to the scene explicitly.</li> </ol> <p></p> Dots connected in a grid network \u2014 connections link alternate cells."},{"location":"guide/08-transforms-and-layout/#arrow-caps","title":"Arrow Caps","text":"<p>Use <code>end_cap=\"arrow\"</code> to add directional arrowheads:</p> <pre><code>arrow_style = ConnectionStyle(width=1.5, color=\"coral\", end_cap=\"arrow\")\nconn = dot1.connect(dot2, style=arrow_style)\n</code></pre> <p></p> Connections with arrow caps create directed graph visualizations. <p>Available caps</p> <p><code>\"round\"</code>, <code>\"square\"</code>, <code>\"butt\"</code>, <code>\"arrow\"</code>, <code>\"arrow_in\"</code>. Use <code>start_cap</code> and <code>end_cap</code> for per-end control.</p>"},{"location":"guide/08-transforms-and-layout/#z_index-layering","title":"z_index Layering","text":"<p>Control draw order with <code>z_index</code> \u2014 higher values render on top:</p> <pre><code>cell.add_fill(color=\"navy\", z_index=0)           # Background\ncell.add_ellipse(fill=\"coral\", opacity=0.2, z_index=1)  # Behind\ncell.add_polygon(Polygon.hexagon(), fill=\"gold\", z_index=2)  # Middle\ncell.add_dot(color=\"white\", z_index=3)            # On top\n</code></pre> <p></p> Four distinct layers: grid lines \u2192 ellipse \u2192 hexagon \u2192 dot."},{"location":"guide/08-transforms-and-layout/#map_range-utility","title":"map_range Utility","text":"<p><code>map_range()</code> maps values between ranges \u2014 useful for converting normalized positions or brightness into visual parameters:</p> <pre><code>from pyfreeform import map_range\n\nradius = map_range(nx, 0, 1, 2, 9)        # nx 0\u21921  maps to  radius 2\u21929\nrotation = map_range(ny, 0, 1, 0, 90)     # ny 0\u21921  maps to  rotation 0\u219290\nopacity = map_range(nx + ny, 0, 2, 0.3, 1.0)\n</code></pre> <p></p> Diamonds where size, rotation, and opacity are all driven by mapped position values. <p>Or just use math</p> <p><code>map_range</code> is convenience sugar. <code>radius = 2 + nx * 7</code> does the same as <code>map_range(nx, 0, 1, 2, 9)</code>.</p>"},{"location":"guide/08-transforms-and-layout/#whats-next","title":"What's Next?","text":"<p>You've completed the Guide! Put your skills to work with self-contained projects:</p> <p>:octicons-arrow-right-24: Browse Recipes</p> <p>Or explore the complete API reference:</p> <p>:octicons-arrow-right-24: API Surface</p>"},{"location":"recipes/","title":"Recipes","text":""},{"location":"recipes/#recipes","title":"Recipes","text":"<p>Complete, self-contained projects. Each recipe builds a finished artwork from start to finish.</p> <ul> <li> <p>Image-to-Art Portraits</p> <p>Transform photos into dot art, halftone, color mosaics, and line art.</p> <p>:octicons-arrow-right-24: Build it</p> </li> <li> <p>Geometric Patterns</p> <p>Checkerboards, hexagonal tilings, wave patterns, and Islamic geometry.</p> <p>:octicons-arrow-right-24: Build it</p> </li> <li> <p>Flowing Curves &amp; Waves</p> <p>Curve fields, wave visualizations, spirals, and flowing textures.</p> <p>:octicons-arrow-right-24: Build it</p> </li> <li> <p>Connected Networks</p> <p>Link entities with connections, arrow caps, and distance-based filtering.</p> <p>:octicons-arrow-right-24: Build it</p> </li> <li> <p>Typographic Art</p> <p>ASCII art, text along paths, curved labels, and text overlays.</p> <p>:octicons-arrow-right-24: Build it</p> </li> <li> <p>Advanced Compositions</p> <p>Multi-layer artwork, reusable motifs, merged regions, combined techniques.</p> <p>:octicons-arrow-right-24: Build it</p> </li> </ul>"},{"location":"recipes/01-image-to-art/","title":"Image-to-Art Portraits","text":""},{"location":"recipes/01-image-to-art/#image-to-art-portraits","title":"Image-to-Art Portraits","text":"<p>Transform photographs into striking generative artwork. Each technique uses <code>Scene.from_image()</code> and a different approach to visualize the image data.</p>"},{"location":"recipes/01-image-to-art/#classic-dot-art","title":"Classic Dot Art","text":"<p>Map brightness to dot radius \u2014 the fundamental image-to-art technique:</p> <pre><code>scene = Scene.from_image(\"MonaLisa.jpg\", grid_size=45, cell_size=9)\n\nfor cell in scene.grid:\n    r = cell.brightness * scene.grid.cell_width * 0.48\n    if r &gt; 0.3:\n        cell.add_dot(radius=r, color=\"#ffffff\")\n</code></pre> <p></p> White dots on dark background \u2014 bright areas shine through larger dots."},{"location":"recipes/01-image-to-art/#color-dot-art","title":"Color Dot Art","text":"<p>Preserve the original image colors for a vibrant result:</p> <pre><code>for cell in scene.grid:\n    r = cell.brightness * scene.grid.cell_width * 0.45\n    if r &gt; 0.3:\n        cell.add_dot(radius=r, color=cell.color, opacity=0.7 + cell.brightness * 0.3)\n</code></pre> <p></p> Full-color dots retain the character's vibrant palette."},{"location":"recipes/01-image-to-art/#halftone-effect","title":"Halftone Effect","text":"<p>Invert the mapping \u2014 dark areas get large dots, simulating print halftone:</p> <pre><code>scene.background = \"#0a0a0a\"\nfor cell in scene.grid:\n    r = (1 - cell.brightness) * scene.grid.cell_width * 0.5  # Inverted!\n    if r &gt; 0.3:\n        cell.add_dot(radius=r, color=\"#e0e0e0\")\n</code></pre> <p></p> Inverted brightness creates a newspaper halftone look."},{"location":"recipes/01-image-to-art/#line-art","title":"Line Art","text":"<p>Replace dots with diagonal lines. Width maps to brightness:</p> <pre><code>for cell in scene.grid:\n    width = cell.brightness * 3\n    if width &gt; 0.2:\n        cell.add_diagonal(width=width, color=cell.color, opacity=0.5 + cell.brightness * 0.5)\n</code></pre> <p></p> Diagonal lines of varying thickness trace the portrait's contours."},{"location":"recipes/01-image-to-art/#color-mosaic","title":"Color Mosaic","text":"<p>The simplest approach \u2014 fill each cell with its sampled color:</p> <p></p> Color fills with thin borders create a stained-glass mosaic."},{"location":"recipes/01-image-to-art/#shape-art","title":"Shape Art","text":"<p>Choose different polygon shapes based on brightness bands:</p> <pre><code>for cell in scene.grid:\n    b = cell.brightness\n    size = 0.4 + b * 0.4\n    if b &lt; 0.3:\n        verts = Polygon.square(size=size)\n    elif b &lt; 0.6:\n        verts = Polygon.hexagon(size=size)\n    else:\n        verts = Polygon.star(points=6, size=size, inner_ratio=0.5)\n    cell.add_polygon(verts, fill=cell.color, opacity=0.6 + b * 0.4)\n</code></pre> <p></p> Squares for shadows, hexagons for midtones, stars for highlights."},{"location":"recipes/02-geometric-patterns/","title":"Geometric Patterns","text":""},{"location":"recipes/02-geometric-patterns/#geometric-patterns","title":"Geometric Patterns","text":"<p>Create mesmerizing patterns using <code>Scene.with_grid()</code>, math, and polygon shapes. No images needed.</p>"},{"location":"recipes/02-geometric-patterns/#checkerboard-with-shape-variations","title":"Checkerboard with Shape Variations","text":"<p>Alternate between two shape types on a checkerboard:</p> <pre><code>for cell in scene.grid.checkerboard(\"black\"):\n    cell.add_polygon(Polygon.diamond(size=0.75), fill=colors.primary, opacity=0.7)\n\nfor cell in scene.grid.checkerboard(\"white\"):\n    cell.add_polygon(Polygon.hexagon(size=0.6), fill=colors.accent, opacity=0.5)\n</code></pre> <p></p> Diamonds and hexagons on alternating cells."},{"location":"recipes/02-geometric-patterns/#rotating-hexagonal-tiling","title":"Rotating Hexagonal Tiling","text":"<p>Position and product drive rotation for an organic feel:</p> <pre><code>for cell in scene.grid:\n    nx, ny = cell.normalized_position\n    rotation = (nx * ny) * 120\n    cell.add_polygon(\n        Polygon.hexagon(size=0.8),\n        fill=colors.primary, stroke=colors.secondary, stroke_width=0.5,\n        opacity=0.3 + t * 0.6, rotation=rotation,\n    )\n</code></pre> <p></p> Hexagons rotate by the product of their coordinates \u2014 organic turbulence."},{"location":"recipes/02-geometric-patterns/#sine-wave-pattern","title":"Sine Wave Pattern","text":"<p>Sine functions create flowing, rhythmic patterns:</p> <pre><code>wave = math.sin(nx * math.pi * 4 + ny * math.pi * 2)\nsize = 0.3 + abs(wave) * 0.5\nfill = colors.primary if wave &gt; 0 else colors.accent\ncell.add_polygon(Polygon.diamond(size=size), fill=fill, rotation=wave * 45)\n</code></pre> <p></p> Diamonds sized and colored by a 2D sine function \u2014 peaks in one color, troughs in another."},{"location":"recipes/02-geometric-patterns/#concentric-rings","title":"Concentric Rings","text":"<p>Use <code>distance_to()</code> to create radial patterns:</p> <pre><code>center = scene.grid[10, 10]\nfor cell in scene.grid:\n    d = cell.distance_to(center)\n    ring = int((d / max_d) * 8) % 2\n    if ring == 0:\n        cell.add_polygon(Polygon.hexagon(size=0.7), fill=colors.primary)\n    else:\n        cell.add_dot(radius=3, color=colors.secondary)\n</code></pre> <p></p> Alternating ring zones with hexagons and dots."},{"location":"recipes/02-geometric-patterns/#star-grid","title":"Star Grid","text":"<p>Star point count and inner ratio driven by grid position:</p> <p></p> Stars evolve from 4-pointed with narrow arms (top-left) to 8-pointed with wide arms (bottom-right)."},{"location":"recipes/03-flowing-curves/","title":"Flowing Curves & Waves","text":""},{"location":"recipes/03-flowing-curves/#flowing-curves-waves","title":"Flowing Curves &amp; Waves","text":"<p>Create organic, flowing compositions using curves, custom paths, and line art.</p>"},{"location":"recipes/03-flowing-curves/#curve-field","title":"Curve Field","text":"<p>Vary curvature by position for a rippling effect:</p> <pre><code>for cell in scene.grid:\n    nx, ny = cell.normalized_position\n    curvature = math.sin(nx * math.pi * 2 + ny * math.pi) * 0.7\n    cell.add_curve(\n        start=\"left\", end=\"right\",\n        curvature=curvature,\n        width=0.5 + ny * 2,\n        color=colors.primary,\n        opacity=0.3 + nx * 0.6,\n    )\n</code></pre> <p></p> Curvature varies sinusoidally \u2014 creating waves of flow across the grid."},{"location":"recipes/03-flowing-curves/#wave-visualization","title":"Wave Visualization","text":"<p>Use a custom <code>Wave</code> pathable with <code>add_path()</code>:</p> <pre><code>class Wave:\n    def __init__(self, x1, y1, x2, y2, amplitude, frequency):\n        self.x1, self.y1, self.x2, self.y2 = x1, y1, x2, y2\n        self.amp, self.freq = amplitude, frequency\n\n    def point_at(self, t):\n        x = self.x1 + t * (self.x2 - self.x1)\n        cy = self.y1 + t * (self.y2 - self.y1)\n        y = cy + self.amp * math.sin(t * self.freq * 2 * math.pi)\n        return Point(x, y)\n</code></pre> <p>Stack multiple waves with different frequencies:</p> <p></p> Eight overlapping waves with increasing frequency and amplitude."},{"location":"recipes/03-flowing-curves/#spiral-paths","title":"Spiral Paths","text":"<p>A custom spiral rendered in each cell:</p> <p></p> Spirals with increasing turns from left to right and thickening strokes downward."},{"location":"recipes/03-flowing-curves/#image-curves","title":"Image Curves","text":"<p>Overlay curves on a photograph \u2014 curvature driven by brightness:</p> <pre><code>scene = Scene.from_image(\"MCEscherBirds.jpg\", grid_size=35, cell_size=10)\nfor cell in scene.grid:\n    if cell.brightness &gt; 0.15:\n        curvature = (cell.brightness - 0.5) * 1.5\n        cell.add_curve(\n            start=\"bottom_left\", end=\"top_right\",\n            curvature=curvature,\n            width=0.5 + cell.brightness * 2,\n            color=cell.color,\n        )\n</code></pre> <p></p> Curves colored and shaped by the source image create an impressionistic effect."},{"location":"recipes/03-flowing-curves/#cross-hatching","title":"Cross-Hatching","text":"<p>Layer perpendicular lines with position-driven weight:</p> <p></p> Two sets of diagonal lines with weight shifting across the grid."},{"location":"recipes/04-connected-networks/","title":"Connected Networks","text":""},{"location":"recipes/04-connected-networks/#connected-networks","title":"Connected Networks","text":"<p>Link entities with connections to create network visualizations, directed graphs, and relationship diagrams.</p>"},{"location":"recipes/04-connected-networks/#brightness-based-networks","title":"Brightness-Based Networks","text":"<p>Connect dots that appear in bright areas of an image:</p> <pre><code>dots = {}\nfor cell in scene.grid:\n    if cell.brightness &gt; 0.35:\n        dot = cell.add_dot(radius=2 + cell.brightness * 3, color=cell.color)\n        dots[(cell.row, cell.col)] = dot\n\nfor (r, c), dot in dots.items():\n    for dr, dc in [(0, 1), (1, 0)]:  # Right and down neighbors\n        key = (r + dr, c + dc)\n        if key in dots:\n            scene.add(dot.connect(dots[key], style=conn_style))\n</code></pre> <p></p> The Mona Lisa's bright areas form a connected network \u2014 her face and hands emerge from the connections."},{"location":"recipes/04-connected-networks/#distance-based-connections","title":"Distance-Based Connections","text":"<p>Only connect dots within a distance threshold, with opacity fading by distance:</p> <pre><code>for i, key1 in enumerate(keys):\n    for key2 in keys[i + 1:]:\n        dist = cell1.distance_to(cell2)\n        if dist &lt; 80:\n            opacity = 0.6 * (1 - dist / 80)\n            scene.add(dots[key1].connect(dots[key2], style=ConnectionStyle(\n                width=0.5 + (1 - dist / 80) * 1.5, color=colors.secondary, opacity=opacity,\n            )))\n</code></pre> <p></p> Connections fade and thin with distance \u2014 nearby dots are strongly linked."},{"location":"recipes/04-connected-networks/#directed-graphs-with-arrows","title":"Directed Graphs with Arrows","text":"<p>Use <code>end_cap=\"arrow\"</code> for directional connections:</p> <pre><code>arrow_style = ConnectionStyle(width=1.5, color=colors.primary, opacity=0.5, end_cap=\"arrow\")\nconn = dot1.connect(dot2, style=arrow_style)\nscene.add(conn)\n</code></pre> <p></p> Arrow caps turn connections into a directed graph."},{"location":"recipes/04-connected-networks/#network-overlay-on-image","title":"Network Overlay on Image","text":"<p>Combine image fills with a network visualization:</p> <p></p> Faded image background with a white connection network linking bright areas."},{"location":"recipes/05-typographic-art/","title":"Typographic Art","text":""},{"location":"recipes/05-typographic-art/#typographic-art","title":"Typographic Art","text":"<p>Create art using text characters, curved labels, and text-along-path effects.</p>"},{"location":"recipes/05-typographic-art/#ascii-art-from-images","title":"ASCII Art from Images","text":"<p>Map brightness to characters from a density string:</p> <pre><code>chars = \" .:-=+*#%@\"\n\nfor cell in scene.grid:\n    idx = int(cell.brightness * (len(chars) - 1))\n    char = chars[idx]\n    if char != \" \":\n        cell.add_text(char, at=\"center\", font_size=7, color=\"#ffffff\", font_family=\"monospace\")\n</code></pre> <p></p> Dense characters for bright areas, sparse for dark \u2014 classic ASCII art."},{"location":"recipes/05-typographic-art/#text-along-curves","title":"Text Along Curves","text":"<p>Warp multiple text lines along curves with different curvatures:</p> <pre><code>curve = cell.add_curve(start=(0.05, 0.2), end=(0.95, 0.25), curvature=0.4, ...)\ncell.add_text(\"Create beautiful art with code\", along=curve, font_size=14, color=colors.primary)\n</code></pre> <p></p> Three phrases flowing along curves with different curvatures and colors."},{"location":"recipes/05-typographic-art/#letter-mosaic","title":"Letter Mosaic","text":"<p>Replace dots with repeated characters from a word:</p> <pre><code>word = \"MONSTER\"\nfor i, cell in enumerate(scene.grid):\n    char = word[i % len(word)]\n    size = 8 + cell.brightness * 8\n    cell.add_text(char, at=\"center\", font_size=size, color=cell.color, bold=True)\n</code></pre> <p></p> The word \"MONSTER\" repeats across the grid, sized by brightness and colored by the image."},{"location":"recipes/05-typographic-art/#combined-dot-art-with-title-overlay","title":"Combined: Dot Art with Title Overlay","text":"<p>Layer dot art with text overlays using merged CellGroups:</p> <pre><code># Dot art layer\nfor cell in scene.grid:\n    cell.add_dot(radius=cell.brightness * 5, color=cell.color, opacity=0.6)\n\n# Title overlay\ntitle = scene.grid.merge(0, 3, 0, scene.grid.cols)\ntitle.add_fill(color=\"#000000\", opacity=0.6)\ntitle.add_text(\"MONA LISA\", at=\"center\", font_size=18, color=\"#ffffff\", bold=True)\n</code></pre> <p></p> Dot art portrait with semi-transparent title and subtitle bars."},{"location":"recipes/06-advanced-compositions/","title":"Advanced Compositions","text":""},{"location":"recipes/06-advanced-compositions/#advanced-compositions","title":"Advanced Compositions","text":"<p>Combine multiple techniques \u2014 layers, groups, merged regions, and connections \u2014 into complex artwork.</p>"},{"location":"recipes/06-advanced-compositions/#multi-layer-artwork","title":"Multi-Layer Artwork","text":"<p>Use <code>z_index</code> to orchestrate four distinct visual layers:</p> <pre><code># Layer 0: subtle grid\ncell.add_border(color=colors.grid, width=0.3, opacity=0.15, z_index=0)\n\n# Layer 1: faded hexagons\ncell.add_polygon(Polygon.hexagon(size=0.6), fill=colors.secondary, opacity=0.15, z_index=1)\n\n# Layer 2: diagonal lines\ncell.add_diagonal(width=0.5 + nx * 1.5, color=colors.primary, opacity=0.25, z_index=2)\n\n# Layer 3: accent dots on every 3rd cell\ncell.add_dot(radius=4, color=colors.accent, opacity=0.7, z_index=3)\n</code></pre> <p></p> Grid \u2192 hexagons \u2192 diagonals \u2192 dots: four layers building up visual density."},{"location":"recipes/06-advanced-compositions/#reusable-entitygroup-motifs","title":"Reusable EntityGroup Motifs","text":"<p>Define a factory function for a reusable crosshair motif:</p> <pre><code>def make_crosshair(color1, color2):\n    g = EntityGroup()\n    g.add(Dot(0, 0, radius=8, color=color1, opacity=0.6))\n    g.add(Line(-12, 0, 12, 0, width=1, color=color2, opacity=0.5))\n    g.add(Line(0, -12, 0, 12, width=1, color=color2, opacity=0.5))\n    g.add(Ellipse(0, 0, rx=10, ry=10, fill=\"none\", stroke=color2, stroke_width=0.5))\n    return g\n\nfor cell in scene.grid:\n    group = make_crosshair(colors.primary, colors.secondary)\n    cell.place(group)\n    group.fit_to_cell(0.8)\n    group.rotate(nx * 45)\n</code></pre> <p></p> Crosshair motifs with rotation varying by position."},{"location":"recipes/06-advanced-compositions/#merged-cellgroup-regions","title":"Merged CellGroup Regions","text":"<p>Use <code>grid.merge()</code> to create distinct regions with different treatments:</p> <pre><code># Feature area\nfeature = scene.grid.merge(2, 8, 3, 9)\nfeature.add_fill(color=colors.primary, opacity=0.15)\nfeature.add_border(color=colors.accent, width=1.5)\nfeature.add_text(\"FEATURED\", at=\"center\", font_size=16, color=colors.accent, bold=True)\n\n# Title bar\ntitle = scene.grid.merge_row(0)\ntitle.add_fill(color=colors.primary, opacity=0.2)\ntitle.add_text(\"COMPOSITION\", at=\"center\", font_size=12, color=colors.accent)\n</code></pre> <p></p> A title bar and featured region created with merged CellGroups."},{"location":"recipes/06-advanced-compositions/#the-full-stack-image-geometry-connections","title":"The Full Stack: Image + Geometry + Connections","text":"<p>Combine every technique into a single composition:</p> <ol> <li>Layer 0: Faded image fills as a background</li> <li>Layer 1: Hexagons sized by brightness</li> <li>Layer 2: White dots on bright cells, connected to neighbors</li> <li>Layer 3: Title overlay on merged cells</li> </ol> <p></p> Image fills, polygons, connections, and text \u2014 every technique working together. <p>Layering strategy</p> <p>Work from background to foreground. Low z_index for ambient elements, high z_index for focal points. Opacity is your best friend for letting layers breathe.</p>"}]}